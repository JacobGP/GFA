;******************************************************************************
;                                                                     
;   Filename: GFA_CHIP_V2009_1.asm                                           
;   Date: Oct. 9, 2009                                           
;   File Version: 2009.0                                         
;   Revised: Tom Carroll, Ph.D. February 8, 2013 - I2C interrupt section                                                                  
;   Author: Donald J. Hammerstrom, Ph.D.                             
;   Company: Battelle, Pacific Northwest Division
;
;   Copyright 2011 Battelle Memorial Institute.  All Rights Reserved.
;                                                                                                                                       
;******************************************************************************
;                                                                     
; 	Files required:                                                  
;                                                                     
;   p16F88.inc Microchip p16f88 INCLUDE file
;	May be backward compatible with p16f819 and its INCLUDE files
;   Various called subroutines.	      
;                                                                                                                                      
;******************************************************************************
;                                                                     
;   Purpose:    			      
;                                                                     
;   This program and its hardware define the Grid Friendly^TM  	      
;   Appliance single-chip response protocol. This chip provides the  
;   means for an appliance manufacturer, automatic meter reader      
;   manufacturer, or other implementer of demand response 	      
;   technologies to define and implement appropriate load responses  
;   to frequency, voltage, and other events like price on the electrical
;   power signal.			      
;				      
;   Notes:                                                           
;                                                                     
; 	Versions 1.x and 2.x addressed development issues that resulted in stable
;	code on the PIC16F819 microprocessor and 24-pin GFA controller. Refer to
;	the project version stored as GFA_CHIP_2007 to see the stepwise version
;	improvements that have been omitted here.
;
;	V2008.0 
;	As of the start of version GFA_CHIP_2008.0, known issues are (1) a 
;	problemmatic I2C communication with a master I2C that does not confirm the 
;	readiness of this slave and (2) a corruption of RAM that was revealed 
;	during low-voltage testing at SCE and can likely be fixed by the brownout 
;	configuration option of the microprocessor. 
;	I am moving to new project folders where I will (1) make the code specific 
;	to the BPA/PSE water heater project controller and (2) prepare a damping 
;	response capability. I am considering upgrading to the PIC16F88, which 
;	has the same footprint with almost twice the memory. - D. Hammerstrom
;	V2008.1
;	 -	Reduced scratch variable names to two letters for readability. This
;		change was required in all modules due to global scratch variables.	
;	 - 	Enabled the power-on and brownout reset configuration bits.
;	 - 	Corrected hysteresis logic on EXT input.
;	 -	This version was not tested in hardware prior to moving on to v2008.2.
;	V2008.2
;	 - 	Simplified I2C code for reliable use with serial-to-I2C converter.
;	V2008.3
;	 -  Revised to use P16F88 processor instead of P16F819. This processor has 
;		a very similar pinout, but it has twice the program memory. Attempt is 
;		made to keep program backward compatible to P16F819.
;	V2009.0
;	 - First succesful operation after transitioning to PIC16F88.
;	 - Revise I2C code to work with printer port communications.
; 	 - Fixed restart delay logic to allow restart delays set to 0. (4/22/09)
;	 - Implemented startup delay that counts half cycles prior to interrupts. 
;		(4/24/09)
;	 - Moved external variable EXT to bank 0, where it can be accessed by I2C
;		writes and reads from the application. (9/30/09)
;	- Successfully extended external variable EXT option by which the value of 
;		EXT can be obtained from A/D measurement at a rate specified by a firmware
;		option in module RTC. The external variable configuration byte dtermines
;		whether input is from I2C or the A/D converter. Operation successful with 
;		water heater controller thermostat.
;	- [REG_FLAGS] now includes feature to send regulation output to [INTERRUPTS],
;		where its status can affect switch status.
;	- Modified RTC module to extend the regulation counter interval and provide 
;		additional interval options.
;	- Added code section for future complex functions. First example is control
;		as a function of both frequency and temperature [EXT] for the water
;		heater controller.
;			FUTURE: Add logic for use with Water Heater controller:
;			X * PinBus interface interaction code
;			X * Timing to limit average relay operation frequency
;			X * Timing to enhance viability of Augmented CVR
;			X * Further testing and revision of damping feature code
;			X * New ability to schedule GFA settings and behaviors
;	- Allowed for regulation endpoint assignments that are not the same as
;		absolute setpoints. (e.g., [P_MAX_REG])
;                                                                     
;******************************************************************************
 	errorlevel  -302		; suppress message 302 (& 205) from list file

	extern	ADD16, DIVIDE_BY_2, EE_WRITE, INIT_INTERRUPTS, INIT_I2C, INIT_PORTS
	extern 	INIT_REGS, INIT_TIMERS, SERVICE_RTC, SUB16, DIV16
	extern	RANDOM_STUFF, RNG		; Subroutines
; Common scratch regs.			
	global	X1, X2, X3, X4, X5, X6, X7, X8 						
; Used by real-time clock subroutine.
	global CYCLE, SECOND, MINUTE, HOUR, DAY, WEEK, YEAR  
; The following counters are used to count down seconds of delay before the
; respective interrupts are released.
	global	PER_MIN_STPT_CNTR, PER_MAX_STPT_CNTR, PER_MIN_REL_CNTR 
	global	PER_MAX_REL_CNTR, V_MIN_STPT_CNTR, V_MAX_STPT_CNTR, V_MIN_REL_CNTR
	global	V_MAX_REL_CNTR, EXT_MIN_STPT_CNTR, EXT_MAX_STPT_CNTR
	global	EXT_MIN_REL_CNTR, EXT_MAX_REL_CNTR
; The following counter registers are used to count half cycles before
; the respective interrupts are asserted. 
	global	P_MAX_SP_SU_CNTR, P_MIN_SP_SU_CNTR, P_MAX_REL_SU_CNTR
	global	P_MIN_REL_SU_CNTR, V_MAX_SP_SU_CNTR, V_MIN_SP_SU_CNTR
	global	V_MAX_REL_SU_CNTR, V_MIN_REL_SU_CNTR, E_MAX_SP_SU_CNTR
	global	E_MIN_SP_SU_CNTR, E_MAX_REL_SU_CNTR, E_MIN_REL_SU_CNTR

	global	PERIOD, VOLTAGE, EXT, AVE_PER, AVE_V, AVE_EXT

	global	AVE_PER_ERROR,PER_REL_FACTOR,PER_MAX_REL,PER_MIN_REL
	global	AVE_V_ERROR,V_REL_FACTOR,V_MAX_REL,V_MIN_REL
	global	AVE_EXT_ERROR,EXT_REL_FACTOR,EXT_MAX_REL,EXT_MIN_REL

	global 	PER_DIST_RANGE, PER_DIST_OFFSET, PER_RESP_CONF
	global	V_DIST_RANGE, V_DIST_OFFSET, V_RESP_CONF
	global 	EXT_DIST_RANGE, EXT_DIST_OFFSET, EXT_RESP_CONF

	global	PER_DLY_RANGE, PER_RESTART_DLY, PER_MIN_DLY
	global	V_DLY_RANGE, V_RESTART_DLY, V_MIN_DLY
	global 	EXT_DLY_RANGE, EXT_RESTART_DLY, EXT_MIN_DLY

	global	REG_FLAGS, REG_CNTR, REG_FRACTION ; Shared for regulation output
	global	I2C_FLAGS, EXT_FLAGS

	list	p=16f88			; preferred processor set to p16F88

; Include this file for the PIC16F88:
	#include <p16F88.inc>

; Select these two configuration lines for the PIC16F88:
	__CONFIG _CONFIG1, _CP_ALL & _CCP1_RB3 & _DEBUG_OFF & _WRT_PROTECT_ALL & _CPD_OFF & _LVP_OFF & _BODEN_ON & _MCLR_ON & _PWRTE_ON & _WDT_OFF & _HS_OSC
	__CONFIG _CONFIG2, _IESO_OFF & _FCMEN_OFF

; '__CONFIG' directive is used to embed configuration word within .asm file.
	;	_CP_OFF: Code protection feature off (NOTE: TURN ON (i.e., _CP_ALL FOR PRODUCTION)
	;	_WRT_ENABLE_OFF: Flash program memory not protected (protect for dist.)
	;	_WRT_PROTECT_ALL: All program memory protected against overwrites
	;	_CPD_OFF: Data EE memory code unprotected
	;   _CCP1_RB3 used to assign TIMER1 capture function to input pin RB3 
	;		(RB2 is being used by serial communications.)
	;	_DEBUG_OFF: In-circuit debugging disabled. RB6 adn RB7 are general purp.
	;	_LVP_OFF: Do not allow low-voltage reprogramming of chip.
	;	_BODEN_ON: Reset on voltage brownout.
	;   _MCLR_ON: used to activate master clear reset pin that can be shared 
	;		with other application processors.
	;   _WDT_OFF: used to disable the watch dog timer function %%%TEST%%% Revisit this to see if WDT might be used %%%%%%%%%%%%%%%%
	;	_PWRTE_ON: enables the power-on reset timer
	;   _HS_OSC: configures oscillator on OSC1 and OSC2 with High Speed oscill.
	;	_IESO_OFF: Internal external switchover mode disabled. (New on PIC16F88)
	;	_FCMEN_OFF: Fail-safe clock monitor disabled. (New on PIC16F88)

; *****************************************************************************
;***** VARIABLE DEFINITIONS ***************************************************
; *****************************************************************************

#define NODE_ADDR	0x02		; I2C address of this device

#define	INT_MSTR_BYTE 	b'00000001'	; Master Interrupt Pin
#define _INT_MSTR_BYTE 	b'11111110'	; NOT(Master Interrupt Pin)
#define INT_F_BYTE 		b'00000100'	; Frequency Interrupt Pin
#define _INT_F_BYTE 	b'11111011'	; NOT(Frequency Interrupt Pin)
#define	INT_V_BYTE 		b'00100000'	; Voltage Interrupt Pin
#define _INT_V_BYTE 	b'11011111'	; NOT(Voltage Interrupt Pin)
#define INT_EXT_BYTE 	b'10000000'	; External Interrupt Pin
#define _INT_EXT_BYTE 	b'01111111'	; NOT(External Interrupt Pin)

#define PB_PROTECT		0x12		; OR TRIS B with this value to protect

	variable	PHEV = 0xFF			; Assign PROD_CLASS variable according to 
	variable 	water_heater = 0x80	; CEBus recommendations, whenever possible.
	variable	dryer = 0x33
	variable	gateway = 0x00

;##############################################################################
;*** PIN ASSIGNMENTS **********************************************************

;******************************************************************************
;*** PORT A ASSIGNMENTS *******************************************************
AN_VOLTS EQU 0x00	; Analog voltage input for frequency and voltage 
					;	measurements
AN_EXT	EQU	0x01	; Analog external input for price and other measurements 
					; (I.e., Temperature for hot water heater app.)
HEART 	EQU 0x02 	; Heartbeat signal output. Used to toggle LED on the 
					;	second.
VREF	EQU	0x03	; High 3.8V A/D reference voltage (may be set externally)
UNASS	EQU	0x04	; Unassigned pin available for troubleshooting.
_MCLR	EQU	0x05	; Master Clear reset pin (Reset when pulled low)
OSC2	EQU	0x06	; Crystal oscillator input pin
OSC1	EQU	0x07	; Crystal oscillator input pin
;*** END PORT A PIN ASSIGNMENTS ***********************************************
;******************************************************************************

;******************************************************************************
;*** PORT B PIN ASSIGNMENTS ***************************************************
_INT_MSTR EQU 0x00	; Bidirectional master interrupt pin (Weak pull-up active)
SDA		EQU	0x01	; I2C data pin (Weak pull-up active)
_INT_F	EQU	0x02	; Frequency interrupt signal output (active low, weak 
					;	pull-up active)
CCP1	EQU	0x03	; Capture input for zero crossing detection. (Weak pull-up 
					;	might be acceptable.)
SCL		EQU	0x04	; I2C synchronous serial clock (Weak pull-up active)
_INT_V	EQU	0x05	; Voltage interrupt signal output (active low, weak pull-up 
					;	active)
LIN 	EQU 0x06	; Linear regulation output. An averaged PWN representation
					;  of an attribute in respect to range.
_INT_EXT EQU	0x07; External signal interrupt signal output (active low, 
					;	weak pull-up active); Also for in-circuit programming
;*** END PORT B PIN ASSIGNMENTS ***********************************************
;******************************************************************************

;*** END PIN ASSIGNMENTS ******************************************************
;##############################################################################

;##############################################################################
;*** READ/WRITE GENERAL PURPOSE REGISTERS [$20 - $6F] {80 bytes} **************
RAM_20_6F	UDATA	0x20	; Uninitialized data section in bank 0.
	;	Total:	41 readable/writable bytes in register 0.
	; 	Clock:	 6
	;	Reg. 	 1
	;	Freq.	13
	;	V:		12
	;	Ext.	12
;******************************************************************************
;*** READ/WRITE REAL-TIME CLOCK REGISTERS: ************************************
; 6 bytes
YEAR	res 1	; (R/W) YEAR OF MANUFACTURE (0 = year 2000)
WEEK	res 1	; (R/W) WEEK OF YEAR (First week is 0; last week is 51)
DAY		res 1	; (R/W) DAY OF WEEK (Monday is 0; Sunday is 6)
HOUR	res 1	; (R/W) HOUR OF WEEK (First hour is 0; last is 167.)
MINUTE	res 1	; (R/W) MINUTE OF HOUR (First minute is 0; last is 59.)
SECOND	res 1	; (R/W) SECOND OF MINUTE (First second is 0; last is 59.)
;*** END READ/WRITE REAL-TIME CLOCK REGISTERS *********************************
;******************************************************************************

;******************************************************************************
;*** READ/WRITE REGULATION REGISTERS ******************************************
; 1 bytes
REG_FLAGS	res 1	; ((R/W) REGULATION OUTPUT FLAGS: (Set on condition.)
	; 7: This bit reflects the state of the regulation output
	; 6; Set if regulation output should affect [INTERRUPTS] and switch output. (ADDED ON 10/9/09 by DJH)
	; 5-4; Unassigned
	; 3-1: Regulation output assignments:
	;	000 absolute frequency
	;	001 relative frequency
	;	010 absolute voltage
	;	011 relative voltage
	;	100	absolute external
	;	101 relative external
	;	110 absolute external (redundant)
	;	111 relative external (redundant)
	; 0: A regulation output interrupt event occurred.
; END READ/WRITE REGULATION REGISTERS *****************************************

;******************************************************************************
;*** READ/WRITE GFA PERIOD (FREQUENCY) MAINTENANCE REGISTERS: *****************
; 12 bytes
PER_MAX_STPT	res 2	; (R/W) PERIOD MAXIMUM SETPOINT: An unmasked interrupt 
						;	occurs if [PERIOD] exceeds this value.
PER_MIN_STPT	res 2	; (R/W) PERIOD MINUMUM SETPOINT: An unmasked interrupt 
						;	occurs if [PERIOD] is below this value.
PER_REL_FACTOR	res 1	; (R/W) PERIOD RELATIVE FACTOR: Number of unit average
						;  distances from mean for relative period thresholds.
						;  There is an implicit division by 16 in this value.
PER_DIST_RANGE	res 1	; (R/W) PERIOD DISTRIBUTION RANGE: Flat period range 
						;	magnitude over which distribution applies. Check 
						;	that 0 < [PER_RANGE] < 255
PER_STARTUP_DLY res 1	; (R/W) PERIOD STARTUP DELAY: Number of half cycles to
						;	wait before asserting any period interrupt.
PER_MIN_DLY		res	1	; (R/W) PERIOD MINIMUM DELAY: Minimum delay in seconds
						;	prior to release of GFA period interrupts. This 
						;	delay may be augmented by a randomized delay up to
						;	duration {PER_DLY_RANGE] seconds.
PER_DLY_RANGE	res 1	; (R/W) PERIOD DELAY RANGE: An randomized delay of this 
						;	range in seconds may be added to [PER_MIN_DLY]. 
						; 	Active only if [PER_RESP_CONF<4>] is set.
						;	CAUTION: The sum of the minimum and range should not
						;	exceed 255 seconds!
PERIOD_HYST		res 1	; (R/W) PERIOD HYSTERESIS: Response hysteresis in 
						;	period responses.
PER_RESP_CONF	res 1	; (R/W) PERIOD RESPONSE CONFIGURATION:
	; 7 Period software interrupts active (1 = software interrupts enabled)
	; 6 Period hardware interrupts active (1 = hardware interrupts enabled)
	; 5 Period event timing release mode (0 = immediate; 1 = delayed)(not used)
	; 4 Period event timing delay mode (0 = set; 1 = randomized up to setting)
	; 3 Period response mode (0 = no hysteresis; 1 = hysteresis) (not used)
	; 2 Period distribution response mode (0 = no distribution; 1 = uniform 
	;	distribution above threshold)
	; 1 Cold load pickup (0 = initialize uninterrupted; 1 = init. interrupted)
	; 0 Unassigned.
PER_INT_HW_MASK	res 1	; (R/W) PERIOD INTERRUPT HARDWARE MASK: (1 = send a
						;	hardware interrupt on corresponding event)
	; 7 The period falls below the absolute value in PER_MIN_STPT
	; 6 The period exceeded absolute value in PER_MAX_STPT
	; 5 The period falls below the relative value in [PER_MIN_REL]
	; 4 The period exceeds the relative value in [PER_MAX_REL]
	; 3 New absolute period data is available for reporting
	; 2 New relative period data is available for reporting
	; 1 Error states detected.
	; 0 Alert the application.
DAMP_FACT		res	1	; (R/W) DAMPING FACTOR; The number of times [dPERIOD]
						; 	will be doubled as it amplifies the degree to 
						; 	which rate of change in period will affect 
						;	responses. Value is limited to 7 or less by code.
;*** END READ/WRITE GFA PERIOD (FREQUENCY) MAINTENANCE REGISTERS **************
;******************************************************************************

;******************************************************************************
;*** READ/WRITE GFA VOLTAGE MAINTENANCE REGISTERS: ****************************
; 11 bytes
V_MAX_STPT		res 2	; (R/W) VOLTAGE MAXIMUM SETPOINT: An unmasked interrupt
						;	occurs if [VOLTAGE] exceeds this value. (Each bit is 
						;	~0.776% of nominal voltage)
V_MIN_STPT		res 2	; (R/W) VOLTAGE MINUMUM SETPOINT: An unmasked interrupt 
						;	occurs if [VOLTAGE] is below this value. (Each bit is 
						;	~0.776% of nominal voltage)
V_REL_FACTOR	res 1	; (R/W) VOLTAGE RELATIVE FACTOR: Number of unit average
						;  distances from mean for relative voltage thresholds.
						;  There is an implicit division by 16 in this value. (I.e.,
						; 	each bit is 6.25% of average deviation.)
V_DIST_RANGE	res 1	; (R/W) VOLTAGE DISTRIBUTION RANGE: Flat period range 
						;	magnitude over which distribution applies. Can be
						;	randomized. Each bit is ~0.776% of nominal voltage)
V_STARTUP_DLY 	res 1	; (R/W) VOLTAGE STARTUP DELAY: Number of half cycles to
						;	wait before asserting a voltage interrupt.
V_MIN_DLY		res	1	; (R/W) VOLTAGE MINIMUM DELAY: Minimum delay in seconds
						;	prior to release of GFA voltage interrupts. This 
						;	delay may be augmented by a randomized delay up to
						;	duration [V_DLY_RANGE] seconds.
V_DLY_RANGE		res 1	; (R/W) VOLTAGE DELAY RANGE: An randomized delay of this 
						;	range in seconds may be added to [V_MIN_DLY]. 
						; 	Active only if [V_RESP_CONF<4>] is set.
						;	CAUTION: The sum of the minimum and range should not
						;	exceed 255 seconds!
V_HYST			res 1	; (R/W) VOLTAGE HYSTERESIS: Response hysteresis in 
						;	voltage responses. Each bit is ~0.776% of nominal
						;	voltage)
V_RESP_CONF		res 1	; (R/W) VOLTAGE RESPONSE CONFIGURATION:
	; 7 Voltage software interrupts active (1 = software interrupts enabled)
	; 6 Voltage hardware interrupts active (1 = hardware interrupts enabled)
	; 5 Voltage event timing release mode (0 = immediate; 1 = delayed)
	; 4 Voltage event timing delay mode (0 = set; 1 = randomized up to setting)
	; 3 Voltage response mode (0 = no hysteresis; 1 = hysteresis)
	; 2 Voltage distribution response mode (0 = no distribution; 1 = uniform 
	;	distribution above threshold)
	; 1 Cold load pickup (0 = initialize uninterrupted; 1 = init. interrupted)
	; 0 Unassigned.
V_INT_HW_MASK	res 1	; (R/W) VOLTAGE INTERRUPT HARDWARE MASK: (1 = send a
						;	hardware interrupt on corresponding event)
	; 7 The voltage falls below the absolute value in V_MIN_STPT
	; 6 The voltage exceeded absolute value in V_MAX_STPT
	; 5 The voltage falls below the relative value in [V_MIN_REL]
	; 4 The voltage exceeds the relative value in [V_MAX_REL]
	; 3 New absolute voltage data is available for reporting
	; 2 New relative voltage data is available for reporting
	; 1 Error states detected.
	; 0 Alert the application.
;*** END READ/WRITE GFA VOLTAGE MAINTENANCE REGISTERS *************************
;******************************************************************************

;******************************************************************************
;*** READ/WRITE GFA EXTERNAL SIGNAL MAINTENANCE REGISTERS: ********************
; 15 bytes
EXT				res 3	; (R/W) EXTERNAL signal register.
						; (Note that EXT moved to bank 0 from bank 1 in 9/09.)
EXT_MAX_STPT	res 2	; (R/W) EXTERNAL MAXIMUM SETPOINT: An unmasked
						;	interrupt occurs if [EXT] exceeds this value.
EXT_MIN_STPT	res 2	; (R/W) EXTERNAL MINUMUM SETPOINT: An unmasked
						;	interrupt occurs if [EXT] is below this value.
EXT_REL_FACTOR	res 1	; (R/W) EXTERNAL RELATIVE FACTOR: Number of unit average
						;  distances from mean for relative external thresholds.
						;  There is an implicit division by 16 in this value.
EXT_DIST_RANGE	res 1	; (R/W) EXTERNAL DISTRIBUTION RANGE: Flat external 
						;	signal range magnitude over which distribution 
						;	applies. Check that 0 < [EXT_RANGE] < 255
EXT_STARTUP_DLY res 1	; (R/W) EXTERNAL STARTUP DELAY: Number of half cycles to
						;	wait before asserting an external interrupt.
EXT_MIN_DLY		res	1	; (R/W) EXTERNAL MINIMUM DELAY: Minimum delay in seconds
						;	prior to release of GFA external variable interrupts. 
						;	This delay may be augmented by a randomized delay up 
						;	to duration [EXT_DLY_RANGE] seconds.
EXT_DLY_RANGE	res 1	; (R/W) EXTERNAL DELAY RANGE: An randomized delay of this 
						;	range in seconds may be added to [EXT_MIN_DLY]. 
						; 	Active only if [EXT_RESP_CONF<4>] is set.
						;	CAUTION: The sum of the minimum and range should not
						;	exceed 255 seconds!
EXT_HYST		res 1	; (R/W) EXTERNAL HYSTERESIS: Response hysteresis in 
						;	external signal responses.
EXT_RESP_CONF	res 1	; (R/W) EXTERNAL RESPONSE CONFIGURATION:
	; 7 External software interrupts active (1 = software interrupts enabled)
	; 6 External hardware interrupts active (1 = hardware interrupts enabled)
	; 5 External event timing release mode (0 = immediate; 1 = delayed)
	; 4 External event timing delay mode (0 = set; 1 = randomized up to setting)
	; 3 External response mode (0 = no hysteresis; 1 = hysteresis)
	; 2 External distribution response mode (0 = no distribution; 1 = uniform 
	;	distribution around threshold)
	; 1 Cold load pickup (0 = initialize uninterrupted; 1 = init. interrupted)
	; 0 External signal source (0 = I2C; 1 = A2D)
EXT_INT_HW_MASK	res 1	; (R/W) EXTERNAL INTERRUPT HARDWARE MASK: (1 = send a
						;	hardware interrupt on corresponding event)
	; 7 The external signal falls below the absolute value in EXT_MIN_STPT
	; 6 The external signal exceeded absolute value in EXT_MAX_STPT
	; 5 The external signal falls below the relative value in [EXT_MIN_REL]
	; 4 The external signal exceeds the relative value in [EXT_MAX_REL]
	; 3 New absolute external signal data is available for reporting
	; 2 New relative external signal data is available for reporting
	; 1 Error states detected.
	; 0 Alert the application.
;*** END READ/WRITE GFA EXTERNAL SIGNAL MAINTENANCE REGISTERS *****************
;******************************************************************************

;*** END READ/WRITE GENERAL PURPOSE REGISTERS *********************************
;##############################################################################

;##############################################################################
;*** READ-ONLY GENERAL PURPOSE REGISTERS [$A0 - $EF] {80 bytes} ***************
RAM_A0_EF UDATA 0xA0	; Uninitialized data section in bank 1.
	;	Total:	49 read only bytes in register bank 1.
	;	Codes:	 5
	;	Status:	 2
	;	Reg.:	 1
	;	Freq:	15
	;	V:		13
	;	Ext.:	13

;******************************************************************************
;*** READ-ONLY MANUFACTURING CODES AND IDS: ***********************************
; 5 bytes
PROD_CLASS	res 1	; (R) PRODUCT CLASS: (CEBus product class numbering.)
MODEL_CODE	res 1	; (R)
YEAR_MONTH	res 1	; (R) YEAR & MONTH: Manufacture date
GFA_ID		res 2	; (R)

;*** END READ-ONLY MANUFACTURING CODES AND IDS ********************************
;******************************************************************************

;******************************************************************************
;*** READ-ONLY GENERAL HIGH-LEVEL DEVICE STATUS REGISTERS *********************
; 2 bytes
INTERRUPTS	res 1	; (R) INTERRUPTS REGISTER: (1 = INTERRUPT ACTIVE)
	; 7:	Regulation interrupt		3: External hardware interrupt
	; 6:	Unassigned software int		2: Unassigned hardware interrupt
	; 5:	Unassigned					1: Voltage hardware interrupt
	; 4:	Unassigned					0: Period hardware interrupt	
ERRORS	res 1	; (R) ERROR REPORTING REGISTER: (Flags set on indicated error)
	; 7: No zero crossing input			3: Serial communications error
	; 6: No A/D voltage signal 			2:
	; 5: System time is uncalibrated	1:
	; 4: Sys. config. has been altered	0:
;*** END READ-ONLY GENERAL HIGH-LEVEL DEVICE STATUS REGISTERS *****************
;******************************************************************************

;******************************************************************************
;*** READ-ONLY REGULATION REGISTERS ******************************************
; 1 byte
REG_FRACTION res 1	; (R) REGULATION FRACTION: Relative position of measured
					; 		property in respect to the range allowed.
; END READ-ONLY REGULATION REGISTERS ******************************************
;******************************************************************************

;******************************************************************************
;** READ-ONLY GFA PERIOD (FREQUENCY) MAINTENANCE REGISTERS: *******************
; 15 bytes
PERIOD			res 3	; (R) PERIOD GFA word: Filtered. Equal to total 
						;	period count divided by 4. ($516100 = 60 Hz)
AVE_PER			res 3	; (R) AVERAGE PERIOD: Calculated average of [PERIOD].
						;	($516100 = 60.0 Hz). Program can be compiled to 
						;	calculate this average with various response times.
AVE_PER_ERROR	res	2	; (R) AVERAGE PERIOD ERROR: Calculated absolute error
						; 	between [PERIOD] and [AVE_PER]. Program can be  
						;	compiled to calculate this average with various 
						;	response times. The upper byte magnitude is similar
						;	to that in [PERIOD]; the lower is fractional.
PER_MAX_REL		res 2	; (R) PERIOD MAXIMUM RELATIVE: Interrupt may be
						;	specified at [AVE_PER] + 
						;	[PER_REL_FACTOR]/16 * [AVE_PER_ERROR]/256.
PER_MIN_REL		res 2 	; (R) PERIOD MINIMUM RELATIVE: Interrupt may be
						;	specified at [AVE_PER] -
						; 	[PER_REL_FACTOR]/16 * [AVE_PER_ERROR]/256.
PER_INTERRUPT	res 1	; (R) PERIOD INTERRUPT: (1 = period interrupt event 
						;	active)
	; 7 The period falls below the absolute value in PER_MIN_STPT
	; 6 The period exceeded absolute value in PER_MAX_STPT
	; 5 The period falls below the relative value in [PER_MIN_REL]
	; 4 The period exceeds the relative value in [PER_MAX_REL]
	; 3 New absolute period data is available for reporting
	; 2 New relative period data is available for reporting
	; 1 Error states detected.
	; 0 Alert the application.
dPERIOD			res	2	; (R) delta PERIOD: Filtered difference between  
						; 	[PERIOD] value and last half-period measurement.
						; 	This value is then amplified by [DAMP_FACT] to 
						; 	include a damping response.
;** END READ-ONLY GFA PERIOD (FREQUENCY) MAINTENANCE REGISTERS: ***************
;******************************************************************************

;******************************************************************************
;** READ-ONLY GFA VOLTAGE MAINTENANCE REGISTERS: ******************************
; 13 bytes
VOLTAGE			res 3	; (R) VOLTAGE word: Present filtered voltage 
						;	measurement. An average voltage magnitude reading.
AVE_V			res 3	; (R) AVERAGE VOLTAGE: Calculated average of [VOLTAGE].
						;	Program can be compiled to calculate this average 
						;	with various response times.
AVE_V_ERROR		res	2	; (R) AVERAGE VOLTAGE ERROR: Calculated absolute error
						; 	between [VOLTAGE] and [AVE_V]. Program can be  
						;	compiled to calculate this average with various 
						;	response times. The upper byte magnitude compares 
						;	to [Voltage]; the lower is fractional.
V_MAX_REL		res 2	; (R) VOLTAGE MAXIMUM RELATIVE: Interrupt may be 
						;	specified at [AVE_V] +
						; 	[V_REL_FACTOR]/16 * [AVE_V_ERROR]/256.
V_MIN_REL		res 2 	; (R) VOLTAGE MINIMUM RELATIVE: Interrupt may be
						;	specified at [AVE_V] -
						; 	[V_REL_FACTOR]/16 * [AVE_V_ERROR]/256.
V_INTERRUPT		res 1	; (R) VOLTAGE INTERRUPT: (1 = period interrupt active)
	; 7 The voltgae falls below the absolute value in V_MIN_STPT
	; 6 The voltage exceeded absolute value in V_MAX_STPT
	; 5 The voltage falls below the relative value in [V_MIN_REL]
	; 4 The voltage exceeds the relative value in [V_MAX_REL]
	; 3 New absolute voltage data is available for reporting
	; 2 New relative voltage data is available for reporting
	; 1 Error states detected.
	; 0 Alert the application.
;** END READ-ONLY GFA VOLTAGE MAINTENANCE REGISTERS ***************************
;******************************************************************************

;******************************************************************************
;** READ-ONLY GFA EXTERNAL SIGNAL MAINTENANCE REGISTERS: **********************
; 10 bytes (Note that EXT variable has been moved to bank 0 on 9/09.)
AVE_EXT		 	res 3	; (R) AVERAGE EXTERNAL: Calculated average of [EXT].
						;	Program can be compiled to calculate this average 
						;	with various response times.
AVE_EXT_ERROR	res	2	; (R) AVERAGE EXTERNAL ERROR: Calculated standard 
						;	deviation of [EXT].  Calculated absolute error
						; 	between [EXT] and [AVE_EXT]. Program can be  
						;	compiled to calculate this average with various 
						;	response times. The upper byte corresponds to the
						; 	magnitudes in [EXT]; the lower byte is fractional.
EXT_MAX_REL	 	res 2	; (R) EXTERNAL MAXIMUM RELATIVE: Interrupt may be
						;	specified at [AVE_V] +
						; 	[V_REL_FACTOR]/16 * [AVE_V_ERROR]/256.
						; 	[EXT_REL_FACTOR]/16 * [AVE_EXT_ERROR]/256.
EXT_MIN_REL		res 2 	; (R) EXTERNAL MINIMUM RELATIVE: Interrupt may be
						;	specified at [AVE_EXT] -
						; 	[EXT_REL_FACTOR]/16 * [AVE_EXT_ERROR]/256.
EXT_INTERRUPT	res 1	; (R) EXTERNAL INTERRUPT: (1 = external interrupt event 
						;	active)
	; 7 The external signal falls below the absolute value in EXT_MIN_STPT
	; 6 The external signal exceeded absolute value in EXT_MAX_STPT
	; 5 The external signal falls below the relative value in [EXT_MIN_REL]
	; 4 The external signal exceeds the relative value in [EXT_MAX_REL]
	; 3 New absolute external data is available for reporting
	; 2 New relative external data is available for reporting
	; 1 Error states detected.
	; 0 Alert the application.
;** END READ-ONLY GFA EXTERNAL SIGNAL MAINTENANCE REGISTERS *******************
;******************************************************************************

;*** END READ-ONLY GENERAL PURPOSE REGISTERS **********************************
;##############################################################################

;##############################################################################
;*** PROTECTED GENERAL PURPOSE REGISTERS: [$120 - $16F] ***********************
; Neither readable nor writable by I2C.
RAM_120_16F UDATA 0x110	; Uninitialized data section in bank 2.

;******************************************************************************
;*** PROTECTED CLOCK REGISTERS ************************************************
CYCLE	res 1	; (-) HALF-CYCLE OF SECOND (Half-cycles from 0 - 119.)
				;  Replaced here from RW registers on 2/6/2008 -DJH.
;*** END PROTECTED CLOCK RESITERS *********************************************
;******************************************************************************

;******************************************************************************
;*** PROTECTED EEPROM MAINTENANCE REGISTERS: **********************************
EEPROM_PTR res 1 ; (-) EEPROM REGISTER POINTER: This pointer moves throughout
				 ;  the rear/write and read-only memory and writes the bytes
				 ;  to a mirrored non-volatile eeprom location that will be 
				 ;  read on the next restart.
;*** END PROTECTED EEPROM MAINTENANCE REGISTERS *******************************
;******************************************************************************

;******************************************************************************
;*** PROTECTED A/D MAINTENANCE REGISTERS: *************************************
A2D_PER	res	1	; (-) A/D SAMPLE PERIOD: Contains the supplement to 256 used
				;	by Timer 0 to specify the A/D sample period. This register
				; 	is modified to match the 60 Hz period.
A2DTMR1SYNCH	res 1	; (-) A2D TIMER1 SYNCHRONIZATION: A stored value of
						;	[TMR1H] that is used to synchronize the A2D
						; 	readings to the center of each half-period.	
;*** END PROTECTED A/D MAINTENANCE REGISTERS **********************************
;******************************************************************************

;******************************************************************************
;*** PROTECTED I2C MAINTENANCE REGISTERS: *************************************
I2C_FLAGS res 1	; (-) I2C FLAGS: Communication status flags set on condition.
	; 7: Received address match		3: Sent register value
	; 6: Received register number	2: Registers have been modified.
	; 5: Received register value	1: Errors detected
	; 4: Sent register number		0: Reset requested
SSPSTAT_TEMP 	res 1	; (-) Stored SSPSTAT register from last comm. interrupt
SSPCON_TEMP		res	1	; (-) Stored SSPCON register from last comm. interrupt
SSP_REG_ADD		res 1	; (-) Stored most recent register addressed by host
I2C_INDEX		res 1	; (-) Data index pointer to next data byte.
;*** END PROTECTED I2c MAINTENANCE REGISTERS **********************************
;******************************************************************************

;******************************************************************************
;*** PROTECTED REGULATION REGISTERS: ******************************************
REG_CNTR		res 1	; (-) REGULAITON COUNTER. Used for assigning PWM output
						;     of regulation status.
PER_MAX_REG		res 2	; (R/W) PERIOD MAXIMUM REGULATION SETPOINT: The upper
						;	threshold of the regulation service. (Set to 
						;	[PER_MAX_STPT] by default.)
PER_MIN_REG		res 2	; (R/W) PERIOD MINUMUM REGULATION SETPOINT: The lower
						;	threshold of the regulation service. (Set to 
						;	[PER_MIN_STPT] by default.)
V_MAX_REG		res 2	; (R/W) VOLTAGE MAXIMUM REGULATION SETPOINT: The upper
						;	threshold of the regulation service. (Set to 
						;	[V_MAX_STPT] by default.)
V_MIN_REG		res 2	; (R/W) VOLTAGE MINUMUM REGULATION SETPOINT: The lower
						;	threshold of the regulation service. (Set to 
						;	[V_MIN_STPT] by default.)
EXT_MAX_REG		res 2	; (R/W) EXTERNAL MAXIMUM REGULATION SETPOINT: The upper
						;	threshold of the regulation service. (Set to 
						;	[EXT_MAX_STPT] by default.)
EXT_MIN_REG		res 2	; (R/W) EXTERNAL MINUMUM REGULATION SETPOINT: The lower
						;	threshold of the regulation service. (Set to 
						;	[EXT_MIN_STPT] by default.)
;*** END PROTECTED REGULATION REGISTERS ***************************************
;******************************************************************************

;******************************************************************************
;*** PROTECTED GFA PERIOD (FREQUENCY) MAINTENANCE REGISTERS: ******************
PER_FLAGS		res 1	; (-) PERIOD FLAGS: (Set on condition)
	; 0 A zero crossing event has occurred and requires service.
PER_OLD			res 2	; (-) Half of last half-period count. Successive half 
						;  of half cycle duration count.
P_MAX_SP_SU_CNTR res 1; (-) PERIOD MAXIMUM SETPOINT STARTUP COUNTER 1/2-cycle
						;	counter. This counter is used with [PER_STARTUP_DLY].
P_MIN_SP_SU_CNTR res 1	; (-) PERIOD MINIMUM SETPOINT STARTUP COUNTER 1/2-cycle
						;	counter. This counter is used with [PER_STARTUP_DLY].
P_MAX_REL_SU_CNTR res 1 ; (-) PERIOD MAXIMUM RELATIVE STARTUP COUNTER 1/2-cycle
						;	counter. This counter is used with [PER_STARTUP_DLY].
P_MIN_REL_SU_CNTR res 1	; (-) PERIOD MINIMUM RELATIVE STARTUP COUNTER 1/2-cycle
						;	counter. This counter is used with [PER_STARTUP_DLY].
PER_MAX_STPT_CNTR res 1 ; (-) PERIOD MAXIMUM SETPOINT COUNTER second timer.
PER_MIN_STPT_CNTR res 1 ; (-) PERIOD MINIMUM SETPOINT COUNTER second timer.
PER_MAX_REL_CNTR res 1 	; (-) PERIOD MAX RELATIVE INTERRUPT COUNTER second timer.
PER_MIN_REL_CNTR res 1 	; (-) PERIOD MIN RELATIVE INTERRUPT COUNTER second timer.
PER_DIST_OFFSET	res 1	; (-) PERIOD DISTRIBUTION OFFSET: Present offset 
						;	of [PERIOD] distribution range. This value is set
						;	to zero when no distributions are allowed.
PER_RESTART_DLY	res 1	; (-) PERIOD RESTART DELAY: Present setting for delay
						;	in seconds prior to release of interrupt on period
						;	variable. This value may be set at value of 
						;	[PER_DLY_RANGE], but it may also be randomized 
						; 	over the range.
;*** END PROTECTED GFA PERIOD (FREQUENCY) MAINTENANCE REGISTERS ***************
;******************************************************************************

;******************************************************************************
;** PROTECTED GFA VOLTAGE MAINTENANCE REGISTERS: ******************************
VOLT_PTR		res 1	; (-) VOLTAGE POINTER: [0-31] Points to sample location 
						;  	in V_BUFFER space.
VOLT_FLAGS		res 1	; (-) VOLTAGE FLAGS: (Set on condition)
	; 7 Set after a new A/D reading was measured and needs servicing
	; 6 Set while waiting for an A/D conversion to be completed
	; 5
	; 4	
V_OLD			res 2	; (-) Last voltage measurement (for filtering) 
						; 
V_MAX_SP_SU_CNTR res 1	; (-) VOLTAGE MAXIMUM SETPOINT STARTUP COUNTER 1/2-cycle
						;	counter.
V_MIN_SP_SU_CNTR res 1	; (-) VOLTAGE MINIMUM SETPOINT STARTUP COUNTER 1/2-cycle
						;	counter.
V_MAX_REL_SU_CNTR res 1	; (-) VOLTAGE MAXIMUM RELATIVE STARTUP COUNTER 1/2-cycle
						;	counter.
V_MIN_REL_SU_CNTR res 1	; (-) VOLTAGE MINIMUM RELATIVE STARTUP COUNTER 1/2-cycle
						;	counter.	
V_MAX_STPT_CNTR res 1 	; (-) VOLTAGE MAXIMUM SETPOINT COUNTER second timer.
V_MIN_STPT_CNTR res 1 	; (-) VOLTAGE MINIMUM SETPOINT COUNTER second timer.
V_MAX_REL_CNTR 	res 1 	; (-) VOLTAGE MAX RELATIVE INTERRUPT COUNTER second timer.
V_MIN_REL_CNTR 	res 1 	; (-) VOLTAGE MIN RELATIVE INTERRUPT COUNTER second timer.
V_DIST_OFFSET	res 1	; (-) VOLTAGE DISTRIBUTION OFFSET: Present signed 
						;	offset of [VOLTAGE] above voltage thresholds. This
						; 	offset may be randomized from 0 through 
						;	[V_DIST_RANGE], otherwise it is set to zero.
V_RESTART_DLY	res 1	; (-) VOLTAGE RESTART DELAY:  Present setting for delay
						;	in seconds prior to release of interrupt on voltage
						;	variable. This value may be set at value of 
						;	[V_DLY_RANGE], but it may also be randomized 
						; 	over the range.	
;** END PROTECTED GFA VOLTAGE MAINTENANCE REGISTERS ***************************
;******************************************************************************

;******************************************************************************
;*** PROTECTED GFA EXTERNAL SIGNAL MAINTENANCE REGISTERS: *********************
EXT_FLAGS		res 1	; (-) EXTERNAL FLAGS: (Set on condition)
	; 7: Service request (0 = OK; 1 = Service requested for external signal)
	; 6: Set while a new A/D reading was taken and needs servicing
	; 5: Set while waiting for an A/D reading to be taken	
	; 4: Set while waiting A2D data acquisition period				
E_MAX_SP_SU_CNTR res 1	; (-) EXTERNAL MAXIMUM SETPOINT STARTUP COUNTER 1/2-cycle
						;	counter.
E_MIN_SP_SU_CNTR res 1	; (-) EXTERNAL MINIMUM SETPOINT STARTUP COUNTER 1/2-cycle
						;	counter.
E_MAX_REL_SU_CNTR res 1	; (-) EXTERNAL MAXIMUM RELATIVE STARTUP COUNTER 1/2-cycle
						;	counter.
E_MIN_REL_SU_CNTR res 1	; (-) EXTERNAL MINIMUM RELATIVE STARTUP COUNTER 1/2-cycle
						;	counter.
EXT_MAX_STPT_CNTR res 1 ; (-) EXTERNAL MAXIMUM SETPOINT COUNTER second timer.
EXT_MIN_STPT_CNTR res 1 ; (-) EXTERNAL MINIMUM SETPOINT COUNTER second timer.
EXT_MAX_REL_CNTR res 1 	; (-) EXTERNAL MAX RELATIVE INTERRUPT COUNTER second timer.
EXT_MIN_REL_CNTR res 1 	; (-) EXTERNAL MIN RELATIVE INTERRUPT COUNTER second timer.
EXT_DIST_OFFSET	res 1	; (-) EXTERNAL DISTRIBUTION OFFSET: Present signed offset 
						;	of [EXT] within distribution range. This offset m
						;	may be randomized from 0 through [EXT_DIST_RANGE], 
						;	otherwise it is set to zero. 
EXT_RESTART_DLY	res 1	; (-) EXTERNAL RESTART DELAY:   Present setting delay
						;	in seconds prior to release of interrupt on the 
						;	external variable. This value may be set at value  
						;	of [EXT_DLY_RANGE], but it may also be randomized 
						; 	over the range.						
;*** END PROTECTED GFA EXTERNAL SIGNAL MAINTENANCE REGISTERS ******************
;******************************************************************************
	
;******************************************************************************
;*** PROTECTED VOLTAGE BUFFER *************************************************
	idata 0x0150	; (-) VOLTAGE BUFFER Ring buffer for A/D readings. Sized to
					;	hold 16 word values from sequential A/D readings.
V_BUFFER	dw	D'606',D'607',D'606',D'607',D'606',D'607',D'606',D'607'
			dw	D'606',D'607',D'606',D'607',D'606',D'607',D'606',D'607'
;*** END PROTECTED VOLTAGE BUFFER *********************************************
;******************************************************************************
						
;*** END PROTECTED GENERAL PURPOSE REGISTERS **********************************
;##############################################################################

;##############################################################################
;*** PROTECTED GENERAL PROCESS AND SCRATCH REGISTERS: [0X70 - 0X7F] ***********
; NOTE: These registers are useful because they are mirrored in all banks.
; This section is neither readable nor writable by I2C.
RAM_70_7F UDATA_SHR 0x70 ; Uninitialized data section.
W_TEMP			res	1	; Storage for W register
STATUS_TEMP		res	1	; Storage for STATUS register
FSR_TEMP		res 1	; Storage for the FSR register
PCLATH_TEMP		res 1	; Storage for the PCLATH page register
TMR1H_TEMP		res 1	; Temporary holding for TMR1
TMR1L_TEMP		res 1	;
X1				res	1	; General purpose scratch registers
X2				res	1	; 
X3				res	1	; 
X4				res	1 	; 
X5				res 1	;
X6				res 1	;
X7				res	1	;
X8				res 1	;
XA				res 1	;
XB				res 1	;

; END PROTECTED GENERAL PROCESS AND SCRATCH REGISTERS *************************
;##############################################################################

;##############################################################################
;*** EEPROM INITIALIZATION DURING ASSEMBLY ************************************
; This section initializes the EPROM during assembly to create reasonable
; starting values in critical registers.
;******************************************************************************
DEEPROM	ORG 0x2120 ; EPROM GFA CHIP GENERAL REGISTERS BANK 0 **********************
; NOTE: Changes should not be made here without making corresponding changes
; in the RAM register set.
; Total 41 readable/writable bytes in register 0.
; 6 clock bytes:
 	de	D'9'			; YEAR 								(9 = 2009) 
	de	D'45'			; WEEK = week of year 				(1 = week of Jan 1)
	de  D'4'			; DAY 								(0 = Monday)
	de	D'16'			; HOUR = hour of day				(12 = noon)
	de 	D'0'			; MINUTE = minute of hour
	de	D'0'			; SECOND = second of minute
; 1 regulation byte:
	de	B'01000000'		; REG_FLAGS 
						; 	REG_FLAGS<6> = 1: reg. output sent to master interrupt
						; 	REG_FLAGS<1-3> = 000: Regulation from absolute frequency
; 13 frequency management bytes:
	de	0x51,0x8D		; [PER_MAX_STPT] Word value			59.95 Hz = $5172
						;									59.875 Hz = $518D
	de	0x51,0x50		; [PER_MIN_STPT] Word value 		(60.05 Hz = $5150)
	de	0x20			; PER_REL_FACTOR					($20 = 2.0 means)
	de 	D'16' 			; PER_DIST_RANGE 					(D'16'=+/-0.045Hz)
						; NOTE: Combination of [PER_MAX_STPT] and [PER_DIST_RANGE]
						; establish flat distribution [59.875-59.920 Hz].
	de  D'12'			; PER_STARTUP_DLY					(D'1' = 1 half cycle)
	de	D'120'			; PER_MIN_DLY						(D'1'=1s)
	de	D'135'			; PER_DLY_RANGE 					(D'1'=1s)
	de	D'11'			; PERIOD_HYST 						(D'3'=~0.01Hz)
	de	B'01111110'		; P_RESP_CONF 
						; <7>=1: Allow HW response			<3>=1: Allow hysteresis
						; <6>=1: Allow recovery delays		<2>=1: Distribute period response
						; <5>=1: Randomize delays			<1>=1: Active Cold Load Pickup
	de 	B'01000000'		; PER_INT_HW_MASK (B'01000000' = Max. abs. period responses)
	de	D'0'			; DAMP_FACT (D'1' = double dPERIOD and let it influence period)
; 12 voltage management bytes:
	de	0x05,0x79		; [V_MAX_STPT] Word value		 	($5E5 = 140 Vrms)
						;									($579 = 130 Vrms)
						;									($50D = 120 Vrms)
	de	0x03,0x69		; [V_MIN_STPT] Word value			($4A1 = 110 Vrms)
						;									($436 = 100 Vrms)
						;									($369 = 94.8Vrms)
	de  0x20		 	; V_REL_FACTOR						(0x20 = 2.0 means)
	de	D'54'			; V_DIST_RANGE 						(D'54' = 5 V)
	de	D'12'			; V_STARTUP_DLY						(D'1' = 1 half cycle)
	de	D'1'			; V_MIN_DLY							(D'1' = 1 s)
	de	D'57'			; V_DLY_RANGE 						(D'57' = 57 s)
	de	D'40'			; V_HYST 							(D'71' = ~7.2 V)
	de	B'00000000'		; V_RESP_CONF (B'00000000' = No interrupts)
	de	B'00000000'		; V_INT_HW_MASK (B'00000000' = none)
; 15 external management bytes:
	de	0x00,0x00,0x00 	; [EXT] External variable
	de	0x00,0x00		; [EXT_MAX_STPT] Word value
	de	0x00,0x00		; [EXT_MIN_STPT] Word value
	de	0x00			; [EXT_REL_FACTOR] 
	de	0x00			; EXT_DIST_RANGE
	de  D'0'			; EXT_STARTUP_DLY					(D'1' = 1 half cycle)
	de	D'0'			; EXT_MIN_DLY						(D'1' = 1s)
	de	D'0'			; EXT_DLY_RANGE 					(D'1' = 1s)
	de	D'0'			; EXT_HYST
	de	B'00000001'		; EXT_RESP_CONF (B'00000001' = Get EXT from A2D (i.e., temperature)
	de 	B'00000000'		; EXT_INT_HW_MASK (B'00000000' = no interrupts)
;*** END EPROM GFA CHIP GENERAL REGISTERS BANK 0 ******************************
;******************************************************************************

;******************************************************************************
	ORG 0x21A0 ; EEPROM GFA CHIP GENERAL REGISTERS BANK 1 *********************
; NOTE: Changes should not be made here without making corresponding changes
; in the RAM register set.
; Total 49 bytes read only in register bank 1.
; 5 code and ID bytes:
	de	water_heater			; [PROD_CLASS]
	de	0x00			; [MODEL_CODE]
	de	0x9A			; [YEAR_MONTH] ($95 = 2009 May) 
	de	0x00,0x00		; [GFA_ID] Word value 
; 2 status bytes:
	de 	0x00			; [INTERRUPTS]
	de 	0x00			; [ERRORS]
; 1 regulation byte:
	de	0x00			; [REG_FRACTION]
; 15 frequency bytes:
	de	0x51,0x61,0x00	; [PERIOD] 					($516100 = 60 Hz period)
	de	0x51,0x61,0x00	; [AVE_PER] 				($516100 = 60 Hz period)
	de	0x00,0x00		; [AVE_PER_ERROR] 		
	de	0x51, 0x73		; [PER_MAX_REL] Word value 	($5173 = 59.95 Hz)
	de	0x51, 0x50		; [PER_MIN_REL] Word value 	($5150 = 60.05 Hz)
	de	0x00			; PER_INTERRUPT
	de	0x00, 0x00		; dPERIOD (0x00 = no change in period)
; 13 voltage bytes:
	de	0x05,0x0D,0x00	; [VOLTAGE] 				($50D.00 = 120 V)
	de	0x05,0x0D,0x00	; [AVE_V]  					($50D.00 = 120 V)
	de	0x00,0x00		; [AVE_V_ERROR]			
	de	0x05,0xE5		; [V_MAX_REL] Word value	($5E5 = 140V)
	de	0x04,0x36		; [V_MIN_REL] Word value	($436 = 100V)
	de	0x00			; V_INTERRUPT
; 10 external service bytes:
; (EXT moved from here to bank 0 in 9/09)
	de	0x00,0x00,0x00 	; [AVE_EXT] 
	de	0x00,0x00		; [AVE_EXT_ERROR]
	de	0x00,0x00		; [EXT_MAX_REL] Word value
	de	0x00,0x00		; [EXT_MIN_REL] Word value
	de	0x00			; EXT_INTERRUPT
;*** END EEPROM GFA CHIP GENERAL REGISTERS BANK 1 *****************************
;******************************************************************************

;*** END EEPROM INITIALIZATION DURING ASSEMBLY ********************************
;##############################################################################

;##############################################################################
; BEGIN MACRO DEFINITIONS *****************************************************

wrdswp macro W1, W2 ; Copy word of data into another work register
	movf	W1,W
	movwf	W2
	movf	W1+1,W
	movwf	W2+1
	endm

byteswp macro B1, B2 ; Copy byte of data into another byte register.
	movf	B1,W
	movwf	B2
	endm

; END MACROS ******************************************************************
;##############################################################################

;##############################################################################
;BEGIN_INTERRUPT_VECTORS ;*****************************************************
;STARTUP 	CODE 		; Vector code program section.
	org 	0x00		;x;
	pagesel	INIT		;x; Two instructions
	goto	INIT		;x; Upon reset, this vector is used.
	org		0x04		;x; Upon hardware interrupt, this vector is used.
	nop					;x; Let service interrupts proceed to location 0x005.
;END_INTERRUPT_VECTOR ;*********************************************************
;##############################################################################

	org 0x05

;##############################################################################
;INTERRUPT_CODE ;**************************************************************
; W_TEMP holds and replaces [WREG]
; STATUS_TEMP holds and replaces [STATUS]
; FSR_TEMP holds and replaces [FSR]
; PCLATH_TEMP holds and replaces [PCLATH]
; TMR1H_TEMP holds the TMR1H reading
; TMR1L_TEMP holds the TRM1L reading

SERVICE	
	movwf	W_TEMP			;x-x; save off current W register contents
	movf	STATUS,W		;x-x; move status register into W register
	movwf	STATUS_TEMP		;x-x; save contents of STATUS register
	movf	PCLATH,W		;x-x; Save contents of PCLATH page register
	movwf	PCLATH_TEMP		;x-x;
	movf	FSR,W			;x-x; Save contents of FSR indirect addressing reg.
	movwf	FSR_TEMP		;x-x;

;******************************************************************************
CCP1_INT ;*********************************************************************

	bcf		PCLATH,3			;0-x; Program memory page 0. 
	clrf	STATUS				;0-0; Upon CCP1 interrupt,
	btfss	PIR1,CCP1IF			;0-0;
	goto	END_CCP1_INT

	byteswp	TMR1H, TMR1H_TEMP 	;0-0; [TMR1H] -> [TMR1H_TEMP]
	byteswp	TMR1L, TMR1L_TEMP 	;0-0; [TMR1L] -> [TMR1L_TEMP]

; <== Timed from here
; Code below was added 3/19/2009 to replace code that had originally been in the 
;  main program loop for the correction of TMR1. Result is accurate and stable. - DJH
; If TMR1L_TEMP = 0, 1, or 2, account for any rollover of TMR1H_TEMP during read.
	movlw	0x02				;0-0;PROTECT 
	subwf	TMR1L_TEMP,W		;0-0;P  
	btfss	STATUS,C			;0-0;P
	incf	TMR1H_TEMP,F		;0-0;P (NOTE: 3/19/2009-Branches equal length.)
; Correct TMR1 for any delays between capture event and now.
; Find the difference between captured time and TMR1 reading.
; Avoid altering CCPR1, which will be used in main code for measuring [PERIOD].
    comf	CCPR1L,W			;0-0;P Two's complement word subtraction:
	addlw	0x01				;0-0;P [TMR1H_TEMP:TMR1L_TEMP]=
	btfsc	STATUS,Z			;0-0;P	[TMR1H_TEMP:TMR1L_TEMP]-[CCPR1H:CCPR1L]
	goto	COMP2				;0-0;P
	addwf	TMR1L_TEMP,F		;0-0;P
	btfsc	STATUS,C			;0-0;P
	incf	TMR1H_TEMP,F		;0-0;P
	movlw	0x17				;0-0;P Correct TMR1 by code delay. Same as below!
	addwf	TMR1L_TEMP,F		;0-0;P (NOTE: Code between read of TMR1_TEMP and 
	btfsc	STATUS,C			;0-0;P	correction of TMR1 measured as 26 on
	incf	TMR1H_TEMP,F		;0-0;P	on 3/19/2009 - DJH)
    comf	CCPR1H,W			;0-0;P
	addwf	TMR1H_TEMP,F		;0-0;P
	goto 	LOAD_TMR1			;0-0;P
COMP2								;P Two's complement caused change in high byte.
	addwf	TMR1L_TEMP,F		;0-0;P
	btfsc	STATUS,C			;0-0;P
	incf	TMR1H_TEMP,F		;0-0;P
	movlw	0x17				;0-0;P Correct TMR1 by code delay. Must be same
	addwf	TMR1L_TEMP,F		;0-0;P  correction in two code paths.
	btfsc	STATUS,C			;0-0;P
	incf	TMR1H_TEMP,F		;0-0;P
	comf	CCPR1H,W			;0-0;P
	addlw	0x01				;0-0;P Correct for two's complement carry.
	addwf	TMR1H_TEMP,F		;0-0;P(NOTE: 3/19/2009 confirmed paths same.)
; Load the elapsed time into TMR1.
LOAD_TMR1
	clrf	TMR1L				;0-0;P Clear TMR1
	clrf	TMR1H				;0-0;P
	movf	TMR1H_TEMP,W		;0-0;P [TMR1] = [TMR1H_TEMP:TMR1L_TEMP]
	movwf	TMR1H				;0-0;P
	movf	TMR1L_TEMP,W		;0-0;P
	movwf	TMR1L				;0-0;P <== Timed to here.
; Code above was added on 3/19/2009 to improve the way TMR1 is corrected for
;  delays that can happen prior to recognition of capture interrupt. -DJH
	bcf		PIR1,CCP1IF			;0-0; Clear the CCP1 interrupt flag and set the 
								;0-0;  software flag to request service.
	bsf		STATUS,RP1			;0-2;
	bsf		PER_FLAGS,0			;0-2;
	goto	DONE_INTERRUPTS 

END_CCP1_INT ;*****************************************************************
;******************************************************************************

;******************************************************************************
TIMER0_INT ;*******************************************************************
	; Assume that the A/D data channel has not changed so acquisition is ok.
	; Prescale setting is 1:32 to allow not more than one clock overflow if
	;	8 samples are taken each half cycle.
	; (Assume PCLATH is still aimed to memory page 0 from previous code section)
	btfss	INTCON,TMR0IF 		;0-x; Did a TMR0 overflow occur?
	goto	END_TIMER0_INT 

	banksel	A2D_PER				;0-2; Yes. Reload TMR0 with the A/D period. 
	byteswp A2D_PER, TMR0		;0-2; [A2D_PER] -> [TMR0]

	clrf	STATUS				;0-0; [TMR1H] -> [A2DTMR1SYNCH]
	movf	TMR1H,W				;0-0;
	bsf		STATUS, RP1			;0-2;
	movwf	A2DTMR1SYNCH		;0-2;
	bsf		VOLT_FLAGS,6		;0-2; Set flag that Voltage A/D conversion has begun (%%%%%New code line on 9/29/09)

	clrf	STATUS				;0-0;
	bcf		PIR1,ADIF			;0-0; Clear the A/D interrupt
	bsf		ADCON0,2			;0-0; Start the A/D conversion
	bcf		INTCON,TMR0IF		;0-0; Clear the Timer 0 interrupt flag
	goto	DONE_INTERRUPTS

END_TIMER0_INT ;***************************************************************
;******************************************************************************

;******************************************************************************
A2D_INT ;**********************************************************************
; (Assume PCLATH still points to memory page 0 from previous code section)
	clrf	STATUS				;0-0; Complete A/D conversion?  
	btfss	PIR1,ADIF			;0-0;
	goto	END_A2D_INT

	bsf		STATUS,RP1			;0-2; Yes. 
	btfss	VOLT_FLAGS,6		;0-2: Was this a voltage reading?
	goto	EXT_EVENT_A2D		;0-2; No. Check if it was an external event reading.

VOLT_EVENT_A2D					;0-2; Yes. This was a voltage measurement.
	bcf		VOLT_FLAGS,6		;0-2; Clear flag. Voltage A/D conversion done. (%%%%%New code line on 9/29/09)
	bsf		VOLT_FLAGS,7		;0-2; Set flag. Voltage value ready.
	; Might choose to clear external event flags here to avoid corruptions.
	goto	A2D_INT_CONTINUE

EXT_EVENT_A2D					;0-2; Check whether this was an external event reading.
	btfss	EXT_FLAGS,5			;0-2; External event?
	goto	A2D_INT_ERRORS		;0-2; No. How did we get here. Maybe check for errors.
	bcf		EXT_FLAGS,5			;0-2; Clear flag. External A2D conversion is complete.
	bsf		EXT_FLAGS,6			;0-2; Set flag. External value is ready.

A2D_INT_ERRORS
	; Place any error code, including flags to be set here. Conditions could be
	;	- getting here without indications of voltage or external A2D reads
	;	- both voltage and external event flags set at the same time

A2D_INT_CONTINUE
	bcf		STATUS,RP1			;0-0; Clear the A/D interrupt flag
	bcf		PIR1,ADIF			;0-0;
	goto	DONE_INTERRUPTS 
END_A2D_INT ;******************************************************************
;******************************************************************************

;******************************************************************************
I2C_INT_CODE ;*****************************************************************

;MACROS ***********************************************************************
; This macro writes WREG into the I2C buffer.
WriteI2C macro ;Macro adopted quite directly from AN734
;BeginWriteI2C 
	banksel	SSPSTAT
	btfsc	SSPSTAT,BF
	goto 	$-1
	banksel SSPCON
;DoI2CWrite
	bcf	SSPCON,WCOL
	movwf	SSPBUF
	btfsc	SSPCON,WCOL
	goto	$-2
	bsf	SSPCON,CKP	; Release the block
	endm

; This macro reads the I2C buffer into WREG.
ReadI2C macro ;Macro adopted quite directly from AN734
	banksel	SSPBUF
	movf	SSPBUF,W
	endm
;END OF MACROS ****************************************************************
;******************************************************************************

	clrf	STATUS				;0-0;
	btfss	PIR1,SSPIF			;0-0; Did an I2C interrupt occur?
	goto 	END_I2C_INT_CODE
	bcf	PIR1,SSPIF		;0-0;

	bsf	STATUS,RP0			;0-1; Recall stored value [SSPSTAT] from last
	movf	SSPSTAT,W			;0-1;	 interrupt and mask out unimportant bits.
	andlw	b'00101101'			;0-1;	
	banksel	SSPSTAT_TEMP		;0-2;
	movwf	SSPSTAT_TEMP		;0-2;

STATE1 ; I2C write operation, last byte was an address byte.
	; Assume we are still in bank 2
	movlw	b'00001001'			;0-2; Are we in state #1?
		;	bits 6-7 must remain cleared
		;	bit 5 = 0 => last byte was an address
		;	bit 4 = 0 => stop bit was not detected last
		;	bit 3 = 1 => start bit was detected last
		;	bit 2 = 0 => write operation state
		;	bit 1 = 0 => Address ok
		;	bit 0 = 1 => Transmit in progress, SSPBUF was full
	xorwf	SSPSTAT_TEMP,W		;0-2;
	btfss	STATUS,Z			;0-2;
	goto	STATE2

;Take these actions in State 1:
	clrf	I2C_INDEX			;0-2; Clear the data index pointer.
	decf	I2C_INDEX,F			;0-2; $FF => [I2C_INDEX]
	ReadI2C						;0-2 -> 0-0; Dummy read of buffer
	goto	DONE_I2C_SERVICE

STATE2 ; I2C write operation, last byte was a data byte.
	movlw	b'00101001'			;2; Are we in state #2?
		;	bits 6-7 must remain cleared
		;	bit 5 = 1 => last byte was data
		;	bit 4 = 0 => stop bit was not detected
		;	bit 3 = 1 => start bit was detected last
		;	bit 2 = 0 => write operation state
		;	bit 1 = 0 => Address ok
		;	bit 0 = 1 => Transmit in progress, SSPBUF was full
	xorwf	SSPSTAT_TEMP,W		;0-2;
	btfss	STATUS,Z			;0-2;
	goto	STATE3

;Take these actions in State 2:
	incfsz	I2C_INDEX,F			;0-2; First received byte is a register address.
	goto	STATE2_NOT_REGISTER

STATE2_REGISTER ; This received data byte was a register address.
	ReadI2C						;0-0; Read the register address.
	bsf		STATUS,RP1			;0-2; [SSPBUF] -> [SSP_REG_ADD]
	movwf	SSP_REG_ADD			;0-2; 
	goto	DONE_I2C_SERVICE

STATE2_NOT_REGISTER ; this received data byte was data to be placed in a reg.
	decf	I2C_INDEX,W			;0-2; [SSP_REG_ADD]+[I2C_INDEX]-1 -> [FSR] (and WREG!)
	addwf	SSP_REG_ADD,W		;0-2; 
	movwf	FSR					;0-2;

TEST_WRITABLE_REGISTERS2; Writable I2C registers selected by firmware.

	variable WritableI2CRegisters = 0
		; 0 - None. No registers may be written to by I2C (all reads permitted)
		;			This is the default condition.
		; 1 - Test. Bank 0 general purpose registers may be written by I2C (all 
		;			reads permitted)
		; 9 - All. All bank 0 and bank 1 registers may be written by I2C (all 
		;			reads permitted)

;******************************************************************************
	If WritableI2CRegisters == 0 	; No I2C writes are permitted.
	goto	WRITE_REGISTER_NOT_OK2 
	endif
;******************************************************************************

;******************************************************************************
	if WritableI2CRegisters == 1 	; Test mode. All bank0 general purpose
									;   registers writable.
; Test the register value in SSP_REG_ADD. Allow writes to only range $20-$6F.		
	sublw	0x6F				;0-2;	Is register greater than $6F?
	btfss	STATUS,C			;0-2;
	goto	WRITE_REGISTER_NOT_OK2

	movf	SSP_REG_ADD,W		;0-2; Is register greater than $1F?
	sublw	0x1F				;0-2;
	btfss	STATUS,C			;0-2;
	goto	WRITE_REGISTER_OK2
	endif ;End of "test" 
;******************************************************************************

;******************************************************************************
	if WritableI2CRegisters == 9 	; All bank 0 and bank 1 registers writable.
	goto	WRITE_REGISTER_OK2
	endif 
;******************************************************************************

; Default allows no I2C writes.

WRITE_REGISTER_NOT_OK2
	ReadI2C						;0-0; Dummy read of problematic I2C data.
	; NOTE: Eventually, set flag here to acknowledge failed write attempt.
	goto	DONE_I2C_SERVICE	; Should not have arrived here. Ignore and exit.

WRITE_REGISTER_OK2
	bcf		STATUS,IRP			;0-2; Indirect addressing must point to banks 0 or 1
	ReadI2C						;0-0; Read the I2C data,
	movwf	INDF				;0-0;	and store it in indexed register.
	bsf		STATUS,RP1			;0-2; Set flag to show that registers have been
	bsf		I2C_FLAGS,2			;0-2;  modified.
	goto	DONE_I2C_SERVICE	; 

STATE3 ; I2C read operation, last byte was an address byte.
	movf	SSPSTAT_TEMP,W
	andlw	b'00101100'		; mask BF in SSPSTAT_TEMP
	xorlw	b'00001100'		;0-2; Are we in state #3?
		;	bits 6-7 must remain cleared
		;	bit 5 = 0 => last byte was address
		;	bit 4 = 0 => stop bit was not detected last
		;	bit 3 = 1 => start bit was detected last
		;	bit 2 = 1 => read operation state
		;	bit 1 = 0 => Address ok
		;	bit 0 = 0 => Transmit in complete, SSPBUF is empty
	btfss	STATUS,Z		;0-2;
	goto	STATE4	

; Take these actions in State 3:
	clrf		I2C_INDEX		;0-2; 0 => [I2C_INDEX] Reset the I2C addressing index.
	movf		SSP_REG_ADD,W	;0-2; [SSP_REG_ADD] -> [FSR]
	movwf		FSR				;0-2;
	bankisel 	YEAR
	movf		INDF,W			;0-0; [INDF] => [SSPBUF]
	WriteI2C				;0-x; Write the first data byte to I2C.
	goto	DONE_I2C_SERVICE

STATE4 ; I2C read operation, last byte was a data byte.
	movlw	b'00101100'		;2; Are we in state #4?
		;	bits 6-7 must remain cleared
		;	bit 5 = 1 => last byte was data
		;	bit 4 = 0 => stop bit was not detected last
		;	bit 3 = 1 => start bit was detected last
		;	bit 2 = 1 => read operation state
		;	bit 1 = 0 => Address ok
		;	bit 0 = 0 => Transmit is complete, SSPBUF is empty
	xorwf	SSPSTAT_TEMP,W	;0-2;
	btfss	STATUS,Z		;0-2;
	goto	STATE5

; Take these actions in State 4:
	incf	I2C_INDEX,F		;0-2; 
	movf	I2C_INDEX,W		;0-2;[SSP_REG_ADD]+[I2C_INDEX] -> [FSR]
	addwf	SSP_REG_ADD,W	;0-2; 
	movwf	FSR				;0-2;
	bcf	STATUS,IRP
	bcf	STATUS,RP1
	movf		INDF,W			;0-0; [INDF] => [SSPBUF]
	WriteI2C				;0-x; Write next data byte into I2C.
	goto	DONE_I2C_SERVICE 

STATE5 ; I2C logic reset by receipt of NACK from master.
	movf	SSPSTAT_TEMP, W	
	andlw	b'00101000'		; Mask RW bit in SSPSTAT
	xorlw	b'00101000'
		;	bits 6-7 must remain cleared
		;	bit 5 = 1 => last byte was data
		;	bit 4 = 0 => stop bit was not detected last
		;	bit 3 = 1 => start bit was detected last
		;	bit 2 = 0 => write operation state
		;	bit 1 = 0 => Address ok
		;	bit 0 = 0 => Transmit in complete, SSPBUF is empty
	btfss	STATUS,Z		;0-2;
	goto	I2C_ERR

; Take these actions on State 5:
; NOTE: It appears no actions are really required here
	bcf		I2C_FLAGS,1		;0-2; Normal completion. Clear error flag.
	goto	DONE_I2C_SERVICE

I2C_ERR ; This is not an allowed state, so something went wrong.
	banksel		SSPBUF		; Select bank 0
	movf		SSPBUF,W	; Clear BF bit
	banksel		SSPCON		; NOP; same bank as SSPBUF
	bcf		SSPCON,SSPOV	; Clear SSPOV overflow		
	bcf		SSPCON,WCOL	; Clear collision
	banksel		PIR1		; NOP; same bank as SSPBUF
	bcf		PIR1,SSPIF	; Clear pending SSP interrupt
	banksel	ERRORS			;0-1; Set serial comm. error flag.
	bsf		ERRORS,3		;0-1;
	banksel	I2C_FLAGS		;0-2;
	bsf		I2C_FLAGS,1		;0-2; Record I2C Error status flag and request reset.
	bsf		I2C_FLAGS,0		;0-2; NOTE: Apply these flags better once application is stable.

DONE_I2C_SERVICE
	clrf	STATUS			;0-0;

END_I2C_INT_CODE ;*************************************************************
;******************************************************************************

DONE_INTERRUPTS
	movf	FSR_TEMP,W		;x-x; Retrieve copy of FSR register
	movwf	FSR				;x-x;
	movf	PCLATH_TEMP,W	;x-x; Retrieve copy of PCLATH page register
	movwf	PCLATH			;x-x;
	movf	STATUS_TEMP,W	;x-x; retrieve copy of STATUS register
	movwf	STATUS			;x-x; restore pre-isr STATUS register contents
	swapf	W_TEMP,F		;x-x;
	swapf	W_TEMP,W		;x-x;
	retfie					;x-x; return from interrupt
END_INTERRUPT_CODE ;***********************************************************
;##############################################################################

PROG0 		CODE		; Allowed code area on program memory page 0.

;##############################################################################
INIT ;** INITIALIZATION CODE **************************************************
	bsf		PCLATH,3		;1-x; Program memory page 1.
	banksel	PCON			;1-1; Reset Power-on-reset and brown-out indicators
	bsf		PCON,NOT_POR	;1-1; This initialization should occur at Power-on
	bsf		PCON,NOT_BOR	;1-1;

	banksel	EEPROM_PTR		;1-2;
	movlw	0x20			;1-2;
	movwf	EEPROM_PTR		;1-2;

	clrf	VOLT_PTR		;1-2;

	clrf	A2D_PER			;1-2; Start with a large value in A2D Period register %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


	call	INIT_REGS		;1-x; Fill registers from EEPROM registers upon reset
	call	INIT_PORTS		;1-x; Initialize Port A & Port B pins
	call	INIT_TIMERS		;1-x; Initialize and start timers 0, 1, and 2
	call	INIT_I2C		;1-x; Initialize I2C serial communications
	call	INIT_INTERRUPTS	;1-x; Initialize and start interrupt handlers

	call	RANDOM_STUFF	;1-x; Initialize all the offsets, delays, dists.

;Clear all the period event counters.
	banksel	PER_MAX_STPT_CNTR	;1-2;
	clrf	PER_MAX_STPT_CNTR
	clrf	PER_MIN_STPT_CNTR
	clrf	PER_MAX_REL_CNTR
	clrf	PER_MIN_REL_CNTR
	clrf	P_MAX_SP_SU_CNTR
	clrf	P_MIN_SP_SU_CNTR
	clrf	P_MAX_REL_SU_CNTR
	clrf	P_MIN_REL_SU_CNTR
;Clear all the voltage event counters.
	clrf	V_MAX_STPT_CNTR		;1-2;
	clrf	V_MIN_STPT_CNTR
	clrf	V_MAX_REL_CNTR
	clrf	V_MIN_REL_CNTR
	clrf	V_MAX_SP_SU_CNTR
	clrf	V_MIN_SP_SU_CNTR
	clrf	V_MAX_REL_SU_CNTR
	clrf	V_MIN_REL_SU_CNTR
;Clear all the external event counters.
	clrf	EXT_MAX_STPT_CNTR	;1-2;
	clrf	EXT_MIN_STPT_CNTR
	clrf	EXT_MAX_REL_CNTR
	clrf	EXT_MIN_REL_CNTR
	clrf	E_MAX_SP_SU_CNTR
	clrf	E_MIN_SP_SU_CNTR
	clrf	E_MAX_REL_SU_CNTR
	clrf	E_MIN_REL_SU_CNTR
	
;******************************************************************************
COLD_LOAD_PICKUP ;*************************************************************
	bcf		PCLATH,3		;0-x; Program memory page 0.  
	clrf	STATUS			;0-0;
	movlw	0xF0			;0-0; $F0 => [WREG]
	btfss	PER_RESP_CONF,1	;0-0; Is cold load pickup configured for period resp?
	goto	NO_PER_CLP
PER_CLP
	bsf		STATUS,RP0		;0-1;	Activate all period interrupts.
	movwf	PER_INTERRUPT	;0-1;	$F0 => [PER_INTERRUPT]
	bcf		STATUS,RP0		;0-0;
NO_PER_CLP	
	btfss	V_RESP_CONF,1	;0-0; Is cold load pickup configured for voltage resp?
	goto	NO_V_CLP
V_CLP
	bsf		STATUS,RP0		;0-1; Activate all voltage interrupts.
	movwf	V_INTERRUPT		;0-1;	$F0 => [V_INTERRUPT]
	bcf		STATUS,RP0		;0-0;
NO_V_CLP
	btfss	EXT_RESP_CONF,1	;0-0; Is cold load pickup conf. for ext. var. resp?
	goto	NO_EXT_CLP
EXT_CLP
	bsf		STATUS,RP0		;0-1; Activate all external variable interrupts.
	movwf	EXT_INTERRUPT	;0-1; $F0 => [EXT_INTERRUPT]
NO_EXT_CLP

END_COLD_LOAD_PICKUP ;*********************************************************
;******************************************************************************

END_INIT ;*********************************************************************
;##############################################################################

;##############################################################################
MAIN ;** MAIN PROGRAM LOOP ****************************************************

;##############################################################################
GFA_FREQUENCY ;** Grid Friendly Chip Frequency Observation ********************
	bcf		PCLATH,3				;0-x; Program memory page 0. 
 	clrf	STATUS					;0-0;
	btfss	PIR1,TMR1IF				;0-0; Has TIMER1 overflowed?
	goto	NO_TIMER1_OVERFLOW

TIMER1_OVERFLOW 					;0-0; Yes. ERROR: Unreliable zero crossing signal.
	bsf		STATUS,RP0				;0-1;
	bsf		ERRORS,6				;0-1; Set error flag for poor zero crossing signal.
	bsf		PER_INTERRUPT,1			;0-1; Set software interrupt flag for errors

	bcf		STATUS,RP0				;0-0; Clear the TIMER1 overflow interrupt flag.
	bcf		PIR1,TMR1IF				;0-0;

NO_TIMER1_OVERFLOW
	bsf		STATUS,RP1				;0-2; No. Has a zero crossing event occurred?
	btfss	PER_FLAGS,0				;0-2;

NO_ZERO_CROSS
	goto	END_GFA_FREQUENCY

ZERO_CROSS	; A zero cross was detected. Manage the period measurement, its 
			;	flags, and the real-time clock.

	banksel	ERRORS					;0-1;
	bcf		ERRORS,6				;0-1; Release error flag for poor zero crossing signal.

; Code that had corrected TMR1 was removed from this point on 3/19/2009. It was unneeded after
;  code was added in the interrupt service for captured events. Result was much improved 
;  frequency measurement accuracy and stability. - DJH

	bcf		STATUS,RP0				;0-0; Get captured CCP1 reading
	bsf		PCLATH,3				;1-0; Service routines are on second prog. mem. page.
									;1-0; Move Captured TIMER1 reading to [X1:X2]
	byteswp CCPR1H, X1				;1-0; [CCPR1H] -> [X1]
	byteswp CCPR1L, X2				;1-0; [CCPR1L] -> [X2]

	bcf		STATUS,C				;1-0; [X1:X2] = [X1:X2] / 2 (unsigned)
	rrf		X1,F					;1-0;
	rrf		X2,F					;1-0;

	bsf		STATUS,RP1				;1-2;
	wrdswp	PER_OLD, X3 			;1-2; [PER_OLD] => [X3:X4]

	call	ADD16					;1-2; [X3:X4] = [X1:X2] + [X3:X4] 

	bcf		STATUS,C				;1-2; [X3:X4] = [X3:X4] / 2 (average unsigned)
	rrf		X3,F					;1-2;
	rrf		X4,F					;1-2;

	wrdswp	X1, PER_OLD 			;1-2; [X1:X2] => [PER_OLD]

	banksel	PERIOD					;1-1;
	wrdswp	PERIOD, X1 				;1-1;	[PERIOD] => [X1:X2]

	call	SUB16 					;1-1; [X3:X4] = [X3:X4] - [X1:X2]

; account for acceleration for damping response. [dPERIOD] > 0 => deceleration. %%%%%%%%%%%%%%%%%%%
; This is not elegant because of rigidity of ADD16 and SUB16 subroutines.
; Effect of filter is
;			[dPERIOD] = [dPERIOD] + (256*(new_period - [PERIOD])-[dPERIOD]) / 8
	wrdswp	X3, X6					;1-1; [X3:X4] -> [X6:X7]
	byteswp	X4, X3					;1-1; [X4] -> [X3] (Multiply by 256 implicit)
	clrf	X4						;1-1;
	wrdswp	dPERIOD, X1				;1-1; [dPERIOD:dPERIOD+1] -> [X1:X2]

	call	SUB16					;1-1; [X3:X4] = [X3:X4] - [X1:X2]

	bcf		STATUS, C				;1-1; [X3:X4] = [X3:X4] / 2 (signed)
	btfsc	X3,7					;1-1;
	bsf		STATUS, C				;1-1;
	rrf		X3, F					;1-1;
	rrf		X4, F					;1-1;

	bcf		STATUS, C				;1-1; [X3:X4] = [X3:X4] / 4 (signed)
	btfsc	X3,7					;1-1;
	bsf		STATUS, C				;1-1;
	rrf		X3, F					;1-1;
	rrf		X4, F					;1-1;

	bcf		STATUS, C				;1-1; [X3:X4] = [X3:X4] / 8 (signed)
	btfsc	X3,7					;1-1;
	bsf		STATUS, C				;1-1;
	rrf		X3, F					;1-1;
	rrf		X4, F					;1-1;

	call	ADD16					;1-1; [X3:X4] = [X3:X4] + [X1:X2]

	wrdswp	X3, dPERIOD				;1-1; [X3:X4] -> [dPERIOD:dPERIOD+1]

	wrdswp	PERIOD, X1				;1-1; [PERIOD] -> [X1:X2]	
	wrdswp	X6, X3					;1-1; [X6:X7] -> [X3:X4]	(restore period error into [X3:X4])
;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	bsf		PCLATH,3				;1-1; Service routines are on second prog. mem. page.

	clrf	X5						;1-1;

	call 	DIVIDE_BY_2				;1-1; [X3:X4:X5] = [X3:X4:X5] / 2 (signed)

	call 	DIVIDE_BY_2				;1-1; [X3:X4;X5] = [X3:X4:X5] / 4 (signed)

	call 	DIVIDE_BY_2				;1-1; [X3:X4;X5] = [X3:X4:X5] / 8 (signed)

;	call 	DIVIDE_BY_2				;1-1; [X3:X4:X5] = [X3:X4:X5] / 16 (signed) %%%% Apparently not needed %%%%%%%%%%%%%%%%%%%%%%%%%

	movf	X5,W					;1-1; [X3:X4] = [X1:X2:PERIOD+2] + [X3:X4:X5]
									;1-1;   						
	addwf	PERIOD+2,F				;1-1;  
	movlw	0x01               		;1-1; 
	bcf		PCLATH,3				;0-x; Program memory page 0.                    
	btfss	STATUS,C				;0-1;
	goto	NC1					
	addwf	X4,F					;0-1;
	btfss	STATUS,C				;0-1;
	goto	NC1	
	addwf	X3,F					;0-1;
NC1
	bsf		PCLATH,3				;1-1; Service routines are on second prog. mem. page.
	call	ADD16					;1-1; [X3:X4] =  [X3:X4] + [X1:X2]

	wrdswp	X3, PERIOD				;1-1;	[X3:X4] => [PERIOD]

; End of period filter ***

	bsf		PER_INTERRUPT,3			;1-1; Set flag for new absolute period data 
									;	available.

;******************************************************************************
A2D_PERIOD_CALCULATION ;*******************************************************
	; [X3:X4] = [PERIOD] = PERIOD_60 / 4 at begining of this code section.
	; The net effect of this code is [A2D_PER] = [PERIOD]/32/4 = [PERIOD]/128.
	; Division by 128 is accomplished by multiplication by 2 and an implicit 
	;	division by 256.
	; I.e., [PERIOD] = 20833 counts at 60 Hz, 20MHz/4, for one-quarter cycle.
	; Timer0 has a 1:32 prescaler applied. So, one-quarter cycle is 651 Timer0
	; 	counts after the prescaler is applied.
	; We further divide the quarter-cycle into 4 more divisions for a total
	; 	of 16 samples per 60-Hz cycle. Then [A2D_PER] should be about 163 
	;	counts.
	banksel	A2D_PER					;x-2;
	rlf		X4,W					;x-2; Calculate A2D period.
	rlf		X3,W					;x-2;
	xorlw	0xFF					;x-2;	Complement byte value
	addlw	0x01					;x-2; Complete two's complement (THIS LINE TEST DJH 9/26/2009)
;	addlw	0x00					;x-2; Correct A2D period if necessary
	movwf	A2D_PER					;x-2;
 			;2; [X3:X4] is unchanged
END_A2D_PERIOD_CALCULATION ;***************************************************
;******************************************************************************

;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
ACCELERATION_OFFSET_BEGIN ;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
; Added to V2008.1 June 2008 by DJ Hammerstrom
; This piece of code modifies the measured period to account for damping response.
; Consider improvements in the checking of [dPERIOD] magnitude which could affect its signed
;	doubling in this code.
; At the start of this code section, [X3:X4] is the filtered version of [PERIOD].
	
	bcf		PCLATH,3				;0-x; (Program memory page 0.)
	clrf	STATUS					;0-0;
	movf	DAMP_FACT,W				;0-0; If [DAMP_FACT] > 0 and < 8, 
	btfsc	STATUS,Z				;0-0;					then [DAMP_FACT] -> [X5]
	goto	ACCELERATION_OFFSET_END	
	andlw	0x07					;0-0;
	movwf	X5						;0-0;
	bsf		STATUS, RP0				;0-1;
	wrdswp	dPERIOD, X1				;0-1; [dPERIOD] -> [X1:X2]
DFX	
	bcf		STATUS,C				;0-1; Double [dPeriod] [DAMP_FACT] times.
	rlf		X2, F					;0-1;					
	rlf		X1, F					;0-1;
	decfsz	X5, F					;0-1;
	goto	DFX	

	bsf		PCLATH,3				;1-1; Service routines are on second prog. mem. page.
	call 	SUB16					;1-1; [X3:X4] = [X3:X4] - [X1:X2]

; [X3:X4] has now been modified to reflect both period and rate of period change.
;	[X3:X4] = [PERIOD] - [dPERIOD] * 2^[DAMP_FACT]

ACCELERATION_OFFSET_END ;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

PERIOD_FLAGS	; Set period condition flags here. Note that this section 
				;	addresses only the condition and never the responses.
				; NOTE: At this starting point, [X3:X4] = [PERIOD]

	bsf		PCLATH,3				;1-x; Service routines are on second prog. mem. page.
	banksel	PER_DIST_OFFSET			;1-2;
	clrf	X1			 			;1-2; [{sign bits}:PER_DIST_OFFSET] => [X1:X2]
	btfsc	PER_DIST_OFFSET,7	 	;1-2;
	decf	X1,F			 		;1-2;
	byteswp	PER_DIST_OFFSET, X2		;1-2; [PER_DIST_OFFSET] -> [X2]

	call	ADD16 					;1-2; [X3:X4] = [X3:X4] + [X1:X2] (offset [PERIOD])

	wrdswp	X3, X1 					;1-2; [X3:X4] => [X1:X2]

	; Now [PERIOD] + [PER_DIST_OFFSET] = [X1:X2]	

;******************************************************************************
PER_MIN_STPT_OFF ;*************************************************************
	; Assume [X1:X2] contains the offset period still.
	bcf		PCLATH,3				;0-x; Program memory page 0.
  	banksel	PER_INTERRUPT			;0-1;	
	btfsc	PER_INTERRUPT,7			;0-1; Is flag set?
	goto	PER_MIN_STPT_NOT_OFF

	bcf		STATUS,RP0				;0-0;
	wrdswp	PER_MIN_STPT, X3 		;0-0; [PER_MIN_STPT] => [X3:X4]

	bsf		PCLATH,3				;1-0; Service routines are on second prog. mem. page.
	call	SUB16					;1-0; [X3:X4] = [X3:X4]-[X1:X2] (unsigned)

	bcf		PCLATH,3				;0-0;
	bsf		STATUS,RP1				;0-2;
	btfss	X3,7					;0-2;[PERIOD]+[PER_DIST_OFFSET] ?<? [PER_MIN_STPT]
; [PERIOD]+[PER_DIST_OFFSET] </= [PER_MIN_STPT]	
	goto	PER_MIN_STPT_CONTINUE2	
; [PERIOD]+[PER_DIST_OFFSET] > [PER_MIN_STPT]
	clrf	P_MIN_SP_SU_CNTR		;0-2; No. Clear the startup counter and end.
	goto	PER_MIN_STPT_NOT_OFF

PER_MIN_STPT_CONTINUE2 					; Yes. Test the startup counter.
	movf	P_MIN_SP_SU_CNTR,W		;0-2;
	bcf		STATUS,RP1				;0-0;
	subwf	PER_STARTUP_DLY,W		;0-0;
	bsf		STATUS,RP0				;0-1;
	btfsc	STATUS,C				;0-1; [P_MIN_SP_SU_CNTR] ?>? [PER_STARTUP_DLY]
	btfsc	STATUS,Z				;0-1; [P_MIN_SP_SU_CNTR] ?=? [PER_STARTUP_DLY]
	bsf		PER_INTERRUPT,7			;0-1; Yes. Set the software interrupt flag.
PER_MIN_STPT_NOT_OFF ;*********************************************************
;******************************************************************************

;******************************************************************************
PER_MAX_STPT_OFF ;*************************************************************
	; Assume [X1:X2] contains the offset period still.

	bcf		PCLATH,3				;0-x; Program memory page 0. 
	banksel	PER_INTERRUPT			;0-1;  
	btfsc	PER_INTERRUPT,6			;0-1; Is flag set?
	goto	PER_MAX_STPT_NOT_OFF

	clrf	STATUS					;0-0;
	wrdswp	PER_MAX_STPT, X3		;0-0; [PER_MAX_STPT] => [X3:X4]

	bsf		PCLATH,3				;1-0; Service routines are on second prog. mem. page.
	call	SUB16					;1-0; [X3:X4] = [X3:X4]-[X1:X2] (unsigned)

	bcf		PCLATH,3				;0-0;
	bsf		STATUS,RP1				;0-2;
	btfsc	X3,7					;0-2;[PERIOD]+[PER_DIST_OFFSET] ?>? [PER_MAX_STPT]
; [PERIOD]+[PER_DIST_OFFSET] > [PER_MAX_STPT]
	goto	PER_MAX_STPT_CONTINUE2
; [PERIOD]+[PER_DIST_OFFSET] </= [PER_MAX_STPT]
	clrf	P_MAX_SP_SU_CNTR		;0-2; No. Clear startup counter and end.
	goto	PER_MAX_STPT_NOT_OFF

PER_MAX_STPT_CONTINUE2					; Yes. Test startup counter.
	movf	P_MAX_SP_SU_CNTR,W		;0-2;
	bcf		STATUS,RP1				;0-0;
	subwf	PER_STARTUP_DLY,W		;0-0; Compare [P_MAX_SP_SU_CNTR] and [PER_STARTUP_DLY].
	bsf		STATUS,RP0				;0-1;
	btfsc	STATUS,C				;0-1; [P_MAX_SP_SU_CNTR] ?>? [PER_STARTUP_DLY]
	btfsc	STATUS,Z				;0-1; [P_MAX_SP_SU_CNTR] ?=? [PER_STARTUP_DLY]
	bsf		PER_INTERRUPT,6			;0-1; Yes. Set the software interrupt flag.
PER_MAX_STPT_NOT_OFF ;*********************************************************
;******************************************************************************

;******************************************************************************
PER_MIN_REL_OFF ;**************************************************************
	; Assume [X1:X2] contains the offset period still.

	bcf		PCLATH,3				;0-x; Program memory page 0.
	banksel	PER_INTERRUPT			;0-1;    
	btfsc	PER_INTERRUPT,5			;0-1; Is flag set?
	goto	PER_MIN_REL_NOT_OFF	

	wrdswp	PER_MIN_REL, X3			;0-1; [PER_MIN_REL] => [X3:X4]

	bsf		PCLATH,3				;1-1; Service routines are on second prog. mem. page.
	call	SUB16					;1-1; [X3:X4] = [X3:X4]-[X1:X2] (unsigned)

	bcf		PCLATH,3				;0-1;
	banksel	P_MIN_REL_SU_CNTR		;0-2;
	btfss	X3,7					;0-2;[PERIOD]+[PER_DIST_OFFSET] ?<? [PER_MIN_REL]
; [PERIOD]+[PER_DIST_OFFSET] </= [PER_MIN_REL]
	goto	PER_MIN_REL_CONTINUE2
; [PERIOD]+[PER_DIST_OFFSET] > [PER_MIN_REL]
	clrf	P_MIN_REL_SU_CNTR		;0-2; No. Clear the startup counter and end.
	goto	PER_MIN_REL_NOT_OFF

PER_MIN_REL_CONTINUE2					; Yes. Test the startup counter.
	movf	P_MIN_REL_SU_CNTR,W		;0-2;
	bcf		STATUS,RP1				;0-0;
	subwf	PER_STARTUP_DLY,W		;0-0; Compare [P_MIN_REL_SU_DLY] and [PER_STARTUP_DLY]
	bsf		STATUS,RP0				;0-1;
	btfsc	STATUS,C				;0-1; [P_MIN_REL_SU_DLY] ?>? [PER_STARTUP_DLY]
	btfsc	STATUS,Z				;0-1; [P_MIN_REL_SU_DLY] ?=? [PER_STARTUP_DLY]
	bsf		PER_INTERRUPT,5			;0-1; Yes. Set the software interrupt flag.
PER_MIN_REL_NOT_OFF	;**********************************************************
;******************************************************************************

;******************************************************************************
PER_MAX_REL_OFF ;**************************************************************
	; Assume [X1:X2] contains the offset period still.
	bcf		PCLATH,3				;0-x; Program memory page 0. 
	banksel	PER_INTERRUPT			;0-1; 
	btfsc	PER_INTERRUPT,4			;0-1; Is flag set?
	goto	PER_MAX_REL_NOT_OFF

	wrdswp	PER_MAX_REL, X3			;0-1; [PER_MAX_REL] => [X3:X4]

	bsf		PCLATH,3				;1-1; Service routines are on second prog. mem. page.
	call	SUB16					;1-1; [X3:X4] = [X3:X4]-[X1:X2] (unsigned)

	bcf		PCLATH,3				;0-1;
	banksel	P_MAX_REL_SU_CNTR		;0-2;
	btfsc	X3,7					;0-2;[PERIOD]+[PER_DIST_OFFSET] ?>? [PER_MAX_REL]
; [PERIOD]+[PER_DIST_OFFSET] > [PER_MAX_REL]
	goto	PER_MAX_REL_CONTINUE2
; [PERIOD]+[PER_DIST_OFFSET] </= [PER_MAX_REL]
	clrf	P_MAX_REL_SU_CNTR		;0-2; No. Clear the startup counter and end.
	goto	PER_MAX_REL_NOT_OFF	

PER_MAX_REL_CONTINUE2					; Yes. Test the startup counter.
	movf	P_MAX_REL_SU_CNTR,W		;0-2;
	bcf		STATUS,RP1				;0-0;
	subwf	PER_STARTUP_DLY,W		;0-0; Compare [P_MAX_REL_SU_CNTR] and [PER_RESTART_DLY]
	bsf		STATUS,RP0				;0-1;	
	btfsc	STATUS,C				;0-1; [P_MAX_REL_SU_CNTR] ?>? [PER_RESTART_DLY]
	btfsc	STATUS,Z				;0-1; [P_MAX_REL_SU_CNTR] ?=? [PER_RESTART_DLY]
	bsf		PER_INTERRUPT,4			;0-1; Yes. Set the software interrupt flag.
PER_MAX_REL_NOT_OFF ;**********************************************************
;******************************************************************************

; Next look at the code segments that can clear software interrupt flags.

	bsf		PCLATH,3				;1-x; Service routines are on second prog. mem. page.
	wrdswp	X1, X3					;1-x; [X1:X2] => [X3:X4]

	clrf	X1						;1-x; [0:PERIOD_HYST] => [X1:X2]
	banksel	PERIOD_HYST				;1-0;
	byteswp PERIOD_HYST, X2			;1-0;

	call	SUB16					;1-0; [X3:X4] = [X3:X4]-[X1:X2] (period decreased by 
									;	hysteresis used to check minima)

	wrdswp	X3, X1					;1-0; [X3:X4] => [X1:X2]

					; [PERIOD]+[PER_DIST_OFFSET]-[PERIOD_HYST]=[X1:X2]

;******************************************************************************	
PER_MIN_STPT_ON ;**************************************************************
	; Assume [X1:X2] contains the offset period still with hysteresis.	
	bcf		PCLATH,3				;0-x; Program memory page 0.
 	bsf		STATUS,RP0				;0-1;
	btfss	PER_INTERRUPT,7			;0-1; Is flag set?
	goto	PER_MIN_STPT_NOT_ON	

	bcf		STATUS,RP0				;0-0;
	wrdswp	PER_MIN_STPT, X3 		;0-0; [PER_MIN_STPT] => [X3:X4]

	bsf		PCLATH,3				;1-0; Service routines are on second prog. mem. page.
	call	SUB16					;1-0; [X3:X4] = [X3:X4]-[X1:X2] (unsigned)

	bcf		PCLATH,3				;0-2;
	bsf		STATUS,RP1				;0-2;
	btfsc	X3,7					;0-2; [PERIOD]+[PER_DIST_OFFSET]-[PERIOD_HYST] 
									;0-2;	... ?>? [PER_MIN_STPT]
; [PERIOD]+[PER_DIST_OFFSET]-[PERIOD_HYST] > [PER_MIN_STPT]
	goto	PER_MIN_STPT_CONTINUE
; [PERIOD]+[PER_DIST_OFFSET]-[PERIOD_HYST] </= [PER_MIN_STPT]
	clrf	PER_MIN_STPT_CNTR		;0-2; No. Clear counter and end.
	goto	PER_MIN_STPT_NOT_ON		;

PER_MIN_STPT_CONTINUE 					; Yes. Test the restart delay counter.
	movf	PER_MIN_STPT_CNTR,W		;0-2; 
	subwf	PER_RESTART_DLY,W		;0-2; Compare [PER_RESTART_DLY] to [PER_MIN_STPT_CNTR]
	banksel	PER_INTERRUPT			;0-1;
; 4/22/09 Added next line to address unlikely condition that equality is missed.
	btfsc	STATUS,C				;0-1; [PER_RESTART_DLY] ?<? [PER_MIN_STPT_CNTR]
	btfsc	STATUS,Z				;0-1; [PER_RESTART_DLY] ?=? [PER_MIN_STPT_CNTR]
	bcf		PER_INTERRUPT,7			;0-1; Yes. Clear the software interrupt flag.
;%%%TEST%%%
PER_MIN_STPT_NOT_ON	;**********************************************************
;******************************************************************************

;******************************************************************************
PER_MIN_REL_ON ;***************************************************************
	; Assume [X1:X2] contains the offset period still with hysteresis.
	banksel	PER_INTERRUPT			;x-1; 
	bcf		PCLATH,3				;0-1; Program memory page 0.  
	btfss	PER_INTERRUPT,5			;0-1; Is flag set?
; PER_MIN_REL interrupt is inactive.
	goto	PER_MIN_REL_NOT_ON
; PER_MIN_REL interrupt flag is active.
	wrdswp	PER_MIN_REL, X3			;0-1; [PER_MIN_REL] => {X3:X4]

	bsf		PCLATH,3				;1-1; Service routines are on second prog. mem. page.
	call	SUB16					;1-1; [X3:X4] = [X3:X4]-[X1:X2] (unsigned)

	bcf		PCLATH,3				;0-1;
	banksel	PER_MIN_REL_CNTR		;0-2;
	btfsc	X3,7					;0-2;[PERIOD]+[PER_DIST_OFFSET]-[PERIOD_HYST] 
									;0-2;	... ?>? [PER_MIN_REL]
; [PERIOD]+[PER_DIST_OFFSET]-[PERIOD_HYST] > [PER_MIN_REL]
	goto	PER_MIN_REL_CONTINUE
; [PERIOD]+[PER_DIST_OFFSET]-[PERIOD_HYST] </= [PER_MIN_REL]	
	clrf	PER_MIN_REL_CNTR		;0-2; No. Clear the counter and end.
	goto	PER_MIN_REL_NOT_ON

PER_MIN_REL_CONTINUE					; Yes. Test the restart delay counter.
	movf	PER_MIN_REL_CNTR,W		;0-2; 
	subwf	PER_RESTART_DLY,W		;0-2; Compare [PER_RESTART_DLY] to [PER_MIN_REL_CNTR]
	banksel	PER_INTERRUPT			;0-1;
	btfsc	STATUS,C				;0-1;[PER_RESTART_DLY] ?<? [PER_MIN_REL_CNTR]
	btfsc	STATUS,Z				;0-1;[PER_RESTART_DLY] ?=? [PER_MIN_REL_CNTR]
	bcf		PER_INTERRUPT,5			;0-1; Yes. Clear the interrupt.
PER_MIN_REL_NOT_ON ;***********************************************************
;******************************************************************************

	; [X1:X2] = [PERIOD]+[PER_DIST_OFFSET]-[PERIOD_HYST]

	bsf		PCLATH,3				;1-x; Service routines are on second prog. mem. page.
	banksel	PERIOD_HYST				;1-0;

	wrdswp	X1, X3					;1-0; [X1:X2] => [X3:X4]

	clrf	X1						;1-0; [0:PERIOD_HYST] => [X1:X2]
	byteswp PERIOD_HYST, X2			;1-0;
			
	call	ADD16					;1-0; [X3:X4] = [X3:X4]+[X1:X2] 

	call	ADD16					;1-0; [X3:X4] = [X3:X4]+[X1:X2] 

	wrdswp	X3, X1					;1-0; [X3:X4] => [X1:X2]

					; [PERIOD]+[PER_DIST_OFFSET]+[PERIOD_HYST]=[X1:X2]
					;	Now ready for comparison with maxima.

;******************************************************************************
PER_MAX_STPT_ON ;**************************************************************
	; Assume [X1:X2] contains the offset period still with hysteresis.
	banksel	PER_INTERRUPT			;x-1;	
	bcf		PCLATH,3				;0-1; Program memory page 0.  
	btfss	PER_INTERRUPT,6			;0-1; Is flag set?
	goto	PER_MAX_STPT_NOT_ON

	bcf		STATUS,RP0				;0-0;
	wrdswp	PER_MAX_STPT, X3		;0-0; [PER_MAX_STPT] => [X3:X4]

	bsf		PCLATH,3				;1-0; Service routines are on second prog. mem. page.
	call	SUB16					;1-0; [X3:X4] = [X3:X4]-[X1:X2] (signed)

	bsf		STATUS,RP1				;1-2;
	bcf		PCLATH,3				;0-2; 
	btfss	X3,7					;0-2; [PERIOD]+[PER_DIST_OFFSET]-[PERIOD_HYST] 
									;0-2;	... ?<? [PER_MAX_STPT]
; [PERIOD]+[PER_DIST_OFFSET]-[PERIOD_HYST] </= [PER_MAX_STPT]
	goto	PER_MAX_STPT_CONTINUE
; [PERIOD]+[PER_DIST_OFFSET]-[PERIOD_HYST] > [PER_MAX_STPT]
	clrf	PER_MAX_STPT_CNTR		;0-2; No. Clear the counter and end.
	goto	PER_MAX_STPT_NOT_ON

PER_MAX_STPT_CONTINUE				;0-2; Yes. Test the restart delay counter.
	movf	PER_MAX_STPT_CNTR,W		;0-2; 
	subwf	PER_RESTART_DLY,W		;0-2; Compare [PER_RESTART_DLY] and [PER_MAX_STPT_CNTR]
	banksel	PER_INTERRUPT			;0-1;
	btfsc	STATUS,C				;0-1;[PER_RESTART_DLY] ?<? [PER_MAX_STPT_CNTR]
	btfsc	STATUS,Z				;0-1;[PER_RESTART_DLY] ?=? [PER_MAX_STPT_CNTR]
	bcf		PER_INTERRUPT,6			;0-1; Yes. Clear the interrupt.
PER_MAX_STPT_NOT_ON ;**********************************************************
;******************************************************************************

;******************************************************************************
PER_MAX_REL_ON ;***************************************************************
	; Assume [X1:X2] contains the offset period still with hysteresis.
	banksel	PER_INTERRUPT			;x-1;
	bcf		PCLATH,3				;0-1; Program memory page 0.  					
	btfss	PER_INTERRUPT,4			;0-1; Is flag set?
	goto	PER_MAX_REL_NOT_ON

	wrdswp	PER_MAX_REL, X3			;0-1; [PER_MAX_REL] => {X3:X4]

	bsf		PCLATH,3				;1-1; Service routines are on second prog. mem. page.
	call	SUB16					;1-1; [X3:X4] = [X3:X4]-[X1:X2] (signed)

	bcf		PCLATH,3				;0-1;
	banksel	PER_MAX_REL_CNTR		;0-2;
	btfss	X3,7					;0-2;[PERIOD]+[PER_DIST_OFFSET]-[PERIOD_HYST] 
									;0-2;	... ?<? [PER_MAX_REL]
; [PERIOD]+[PER_DIST_OFFSET]-[PERIOD_HYST] </= [PER_MAX_REL]
	goto	PER_MAX_REL_CONTINUE
; [PERIOD]+[PER_DIST_OFFSET]-[PERIOD_HYST] > [PER_MAX_REL]
	clrf	PER_MAX_REL_CNTR		;0-2; No.Clear reset delay counter and end.
	goto	PER_MAX_REL_NOT_ON
	
PER_MAX_REL_CONTINUE					; Yes. Test the reset delay counter.
	movf	PER_MAX_REL_CNTR,W		;0-2; 
	subwf	PER_RESTART_DLY,W		;0-2; Compare [PER_RESTART_DLY] and [PER_MAX_REL_CNTR]
	banksel	PER_INTERRUPT			;0-1;
	btfsc	STATUS,C				;0-1; [PER_RESTART_DLY] ?<? [PER_MAX_REL_CNTR]
	btfsc	STATUS,Z				;0-1; [PER_RESTART_DLY] ?=? [PER_MAX_REL_CNTR]
	bcf		PER_INTERRUPT,4			;0-1; Yes. Clear interrupt.
PER_MAX_REL_NOT_ON ;***********************************************************
;******************************************************************************

	bsf		PCLATH,3				;1-x; Service routines are on second prog. mem. page.
	call	SERVICE_RTC				;1-x; Manage the internal clock here.

	banksel PER_FLAGS				;1-2; Release software flag after zero cross service.
	bcf		PER_FLAGS,0				;1-2;

END_GFA_FREQUENCY ;************************************************************
;##############################################################################

;##############################################################################
GFA_VOLTAGE ;** Grid Friendly Chip Voltage Observation ************************
	banksel	VOLT_FLAGS				;x-2; New voltage reading available?
	bcf		PCLATH,3				;0-2; Program memory page 0.  
	btfss	VOLT_FLAGS,7			;0-2;
	goto	END_GFA_VOLTAGE

									;0-2; Yes. Clear A2D flag until next available 
	bcf		VOLT_FLAGS,7			;0-2;  voltage reading is made.

	bankisel V_BUFFER				;0-2;	Manage buffer that averages last period.
	movlw	V_BUFFER				;0-2; Point to voltage sample buffer for ind. address
	addwf	VOLT_PTR,W				;0-2; 
	movwf	FSR						;0-2;

	bcf		STATUS,RP1				;0-0;
	byteswp ADRESH, INDF			;0-0; [ADRESH] -> [INDF]
	incf	FSR,F					;0-0;
	bsf		STATUS,RP0				;0-1;
	byteswp	ADRESL, INDF			;0-1; [ADRESL] -> [INDF]

	banksel	VOLT_PTR				;0-2;	Pointer managed within 32 byte space.
	incf	VOLT_PTR,F				;0-2;
	incf	VOLT_PTR,F				;0-2;
	movlw	0x1E					;0-2; Only allow even addresses for 2-byte values.
	andwf	VOLT_PTR,F				;0-2;

; New code on June 4, 2008. 
	movlw	0xEF					;0-2; Twice per period,
	andwf	VOLT_PTR,W				;0-2; 	i.e., when [VOLT_PTR] = 0x00, 0x10
	bcf		PCLATH,3				;0-2; Program memory page 0.  
	btfss	STATUS,Z				;0-2;
	goto	END_GFA_VOLTAGE	

;******************************************************************************
A2D_SYNCHRONIZE ;**************************************************************
; Added at V2008.1 June 2008 by DJ Hammerstrom.
; This code uses the Timer1 high byte during last A2D interrupt to synchronize
;	the A2D measurements to the center of each half cycle. This code was moved
;	here to lessen interrupt timing burdens and to move the correction of TMR0
;	far away from its overflow condition.
	banksel	PERIOD				;x-1; [X1] = [A2DTMR1SYNCH] - 0.25 * [PERIOD]
	movf	PERIOD,W			;x-1;
	banksel	A2DTMR1SYNCH		;x-2;
	subwf	A2DTMR1SYNCH,F		;x-2;(Signed error value from about -80 to 80) 

	movlw	0xF0				;x-2; [A2DTMR1SYNCH] = [A2DTMR1SYNCH]/16
	andwf	A2DTMR1SYNCH,F		;x-2;
	swapf	A2DTMR1SYNCH,F		;x-2;
	clrw						;x-2;
	btfsc	A2DTMR1SYNCH, 3		;x-2;
	movlw	0xF0				;x-2;
	iorwf	A2DTMR1SYNCH,W		;x-2;

	addwf	TMR0,W				;x-2; Make correction only if doing so will
	btfss	STATUS,C			;x-2;	not create a carry condition.
	movwf	TMR0				;x-2;

END_A2D_SYNCHRONIZE ;**********************************************************
;******************************************************************************

;	bcf		PCLATH,3				;x; Program memory page 0.  
;	btfss	STATUS,Z				;2; Once each period, ...
;	goto	END_GFA_VOLTAGE 

;******************************************************************************
V_BUFF_ADD ;*******************************************************************

	clrf	X3				;2;
	clrf	X4				;2;
	movlw	D'16'			;2;
	movwf	X5				;2;
	movlw	V_BUFFER		;2;
	movwf	FSR				;2;
	bankisel	V_BUFFER	;2;
ADD_AGAIN					;2; [V_BUFFER_i] => [X1:X2]
	byteswp INDF, X1		;2; [INDF] -> [X1]
	incf	FSR,F			;2;
	byteswp	INDF, X2		;2; [INDF] -> [X2]
	incf	FSR,F			;2;

	bsf		PCLATH,3		;2; Service routines are on second prog. mem. page.
	call	ADD16			;2; [X3:X4] = [X3:X4] + [X1:X2]

	bcf		PCLATH,3		;x; Program memory page 0.  
	decfsz	X5,F			;2;
	goto	ADD_AGAIN
	
	bsf		PCLATH,3		;x; Service routines are on second prog. mem. page.
	call	DIVIDE_BY_2		;x; [X3:X4:X5] = [X3:X4:X5] / 8
	bsf		PCLATH,3		;x; Service routines are on second prog. mem. page.
	call	DIVIDE_BY_2		;x; 1 V = 10.78 units for 120V systems
	bsf		PCLATH,3		;x; Service routines are on second prog. mem. page.
	call	DIVIDE_BY_2		;x; 1 V = 5.39 units for 240V systems

	banksel	VOLTAGE			;1;
	wrdswp	X3, VOLTAGE		;1; [X3:X4] => [VOLTAGE]
	byteswp	X5, VOLTAGE+2	;1; [X5] => [VOLTAGE+2]

END_V_BUFF_ADD ;***************************************************************
;******************************************************************************
VOLTAGE_FLAGS	; Set voltage condition flags here. Note that this section 
				;	addresses only the condition and never the responses.
				; NOTE: At this starting point, [X3:X4] = [VOLTAGE]

	banksel	V_DIST_OFFSET	;2;
	clrf	X1				;2; [{sign bits}:V_DIST_OFFSET] => [X1:X2]
	btfsc	V_DIST_OFFSET,7	;2;
	decf	X1,F			;2;
	byteswp V_DIST_OFFSET, X2	;2; [V_DIST_OFFSET] -> [X2]

	bsf		PCLATH,3		;2; Service routines are on second prog. mem. page.
	call	ADD16 			;2; [X3:X4] = [X3:X4] + [X1:X2] (offset [VOLTAGE])

	wrdswp	X3, X1			;2; [X3:X4] => [X1:X2]

	; Now [VOLTAGE] + [V_DIST_OFFSET] = [X1:X2]	

;******************************************************************************
V_MIN_STPT_OFF ;*************************************************************
	; Assume [X1:X2] contains the offset voltage still.
	banksel	V_INTERRUPT		;x-1;	
	bcf		PCLATH,3		;0-1; Program memory page 0.  
	btfsc	V_INTERRUPT,7	;0-1; Is flag set?
	goto V_MIN_STPT_NOT_OFF	

	clrf	STATUS			;0-0;
	wrdswp	V_MIN_STPT, X3	;0-0; [V_MIN_STPT] => [X3:X4]

	bsf		PCLATH,3		;1-0; Service routines are on second prog. mem. page.
	call	SUB16			;1-0; [X3:X4] = [X3:X4]-[X1:X2] (signed)
	
	bcf		PCLATH,3		;0-0;
	bsf		STATUS,RP1		;0-2;
	btfss	X3,7			;0-2;	[VOLTAGE]+[V_DIST_OFFSET] ?<? [V_MIN_STPT]
; [VOLTAGE]+[V_DIST_OFFSET] </= [V_MIN_STPT]
	goto	V_MIN_STPT_CONTINUE2
; [VOLTAGE]+[V_DIST_OFFSET] > [V_MIN_STPT]
	clrf	V_MIN_SP_SU_CNTR	;0-2; No. Clear startup counter and end.
	goto	V_MIN_STPT_NOT_OFF

V_MIN_STPT_CONTINUE2				; Yes. Test the startup counter.
	movf	V_MIN_SP_SU_CNTR,W	;0-2;
	bcf		STATUS,RP1			;0-0;
	subwf	V_STARTUP_DLY,W		;0-0; Compare [V_MIN_SP_SU_CNTR] and [V_STARTUP_DLY].
	bsf		STATUS,RP0			;0-1;
	btfsc	STATUS,C			;0-1; [V_MIN_SP_SU_CNTR] ?>? [V_STARTUP_DLY]
	btfsc	STATUS,Z			;0-1; [V_MIN_SP_SU_CNTR] ?=? [V_STARTUP_DLY]
	bsf		V_INTERRUPT,7		;0-1; Yes. Set the software interrupt flag.
V_MIN_STPT_NOT_OFF ;*********************************************************
;******************************************************************************

;******************************************************************************
V_MAX_STPT_OFF ;*************************************************************
	; Assume [X1:X2] contains the offset voltage still.
	bcf		PCLATH,3		;0-x; Program memory page 0. 
	banksel	V_INTERRUPT		;0-1; 
	btfsc	V_INTERRUPT,6	;0-1; Is flag set?
	goto V_MAX_STPT_NOT_OFF	

	bcf		STATUS,RP0		;0-0;
	wrdswp	V_MAX_STPT, X3	;0-0; [V_MAX_STPT] => [X3:X4]

	bsf		PCLATH,3		;1-0; Service routines are on second prog. mem. page.
	call	SUB16			;1-0; [X3:X4] = [X3:X4]-[X1:X2] (signed)

	bcf		PCLATH,3		;0-0;
	bsf		STATUS,RP1		;0-2;
	btfsc	X3,7			;0-2;	[VOLTAGE]+[V_DIST_OFFSET] ?>? [V_MAX_STPT]
; [VOLTAGE]+[V_DIST_OFFSET] > [V_MAX_STPT]
	goto	V_MAX_STPT_CONTINUE2
; [VOLTAGE]+[V_DIST_OFFSET] </= [V_MAX_STPT]
	clrf	V_MAX_SP_SU_CNTR	;0-2; No. Clear the startup counter and end.
	goto	V_MAX_STPT_NOT_OFF

V_MAX_STPT_CONTINUE2				; Yes. Test the startup counter.
	movf	V_MAX_SP_SU_CNTR,W	;0-2;
	bcf		STATUS,RP1			;0-0;
	subwf	V_STARTUP_DLY,W		;0-0; Compare [V_MAX_SP_SU_CNTR] and [V_STARTUP_DLY]
	bsf		STATUS,RP0			;0-1;
	btfsc	STATUS,C			;0-1; [V_MAX_SP_SU_CNTR] ?>? [V_STARTUP_DLY]
	btfsc	STATUS,Z			;0-1; [V_MAX_SP_SU_CNTR] ?=? [V_STARTUP_DLY]
	bsf		V_INTERRUPT,6		;0-1; Yes. Set the software interrupt flag.
V_MAX_STPT_NOT_OFF ;*********************************************************
;******************************************************************************

;******************************************************************************
V_MIN_REL_OFF ;**************************************************************
	; Assume [X1:X2] contains the offset voltage still.
	bcf		PCLATH,3		;0-x; Program memory page 0.  
	banksel	V_INTERRUPT		;0-1;
	btfsc	V_INTERRUPT,5	;0-1; Is flag set?
	goto V_MIN_REL_NOT_OFF

	wrdswp	V_MIN_REL, X3	;0-1; [V_MIN_REL] => [X3:X4]

	bsf		PCLATH,3		;1-1; Service routines are on second prog. mem. page.
	call	SUB16			;1-1; [X3:X4] = [X3:X4]-[X1:X2] (signed)

	bcf		PCLATH,3		;0-1;
	banksel	V_MIN_REL_SU_CNTR	;0-2;
	btfss	X3,7			;0-2; [VOLTAGE]+[V_DIST_OFFSET] ?<? [V_MIN_REL]
; [VOLTAGE]+[V_DIST_OFFSET] </= [V_MIN_REL]
	goto	V_MIN_REL_CONTINUE2
; [VOLTAGE]+[V_DIST_OFFSET] > [V_MIN_REL]
	clrf	V_MIN_REL_SU_CNTR	;0-2; No. Clear the startup counter and end.
	goto	V_MIN_REL_NOT_OFF

V_MIN_REL_CONTINUE2				; Yes. Test the startup counter.
	movf	V_MIN_REL_SU_CNTR,W	;0-2;
	bcf		STATUS,RP1			;0-0;
	subwf	V_STARTUP_DLY,W		;0-0; Compare [V_MIN_REL_SU_CNTR] and [V_STARTUP_DLY]
	bsf		STATUS,RP0			;0-1;
	btfsc	STATUS,C			;0-1; [V_MIN_REL_SU_CNTR] ?>? [V_STARTUP_DLY]
	btfsc	STATUS,Z			;0-1; [V_MIN_REL_SU_CNTR] ?=? [V_STARTUP_DLY]
	bsf		V_INTERRUPT,5	;0-1; Yes. Set the software interrupt flag.
V_MIN_REL_NOT_OFF	;**********************************************************
;******************************************************************************

;******************************************************************************
V_MAX_REL_OFF ;**************************************************************
	; Assume [X1:X2] contains the offset period still.

	bcf		PCLATH,3		;0-x; Program memory page 0.  
	banksel	V_INTERRUPT		;0-1;
	btfsc	V_INTERRUPT,4	;0-1; Is flag set?
	goto V_MAX_REL_NOT_OFF

	wrdswp	V_MAX_REL, X3	;0-1; [V_MAX_REL] => [X3:X4]

	bsf		PCLATH,3		;1-1; Service routines are on second prog. mem. page.
	call	SUB16			;1-1; [X3:X4] = [X3:X4]-[X1:X2] (signed)

	bcf		PCLATH,3		;0-1;
	banksel	V_MAX_REL_SU_CNTR	;0-2;
	btfsc	X3,7			;0-2; [VOLTAGE]+[V_DIST_OFFSET] ?>? [V_MAX_REL]
; [VOLTAGE]+[V_DIST_OFFSET] > [V_MAX_REL]
	goto	V_MAX_REL_CONTINUE2
; [VOLTAGE]+[V_DIST_OFFSET] </= [V_MAX_REL]
	clrf	V_MAX_REL_SU_CNTR	;0-2; No. Clear the restart counter and end.
	goto	V_MAX_REL_NOT_OFF

V_MAX_REL_CONTINUE2				; Yes. Test the restart counter.
	movf	V_MAX_REL_SU_CNTR,W ;0-2;
	bcf		STATUS,RP1			;0-0;
	subwf	V_STARTUP_DLY,W		;0-0; Compare [V_MAX_REL_SU_CNTR] and [V_STARTUP_DLY]
	bsf		STATUS,RP0			;0-1;
	btfsc	STATUS,C			;0-1; [V_MAX_REL_SU_CNTR] ?>? [V_STARTUP_DLY]
	btfsc	STATUS,Z			;0-1; [V_MAX_REL_SU_CNTR] ?=? [V_STARTUP_DLY]
	bsf		V_INTERRUPT,4		;0-1; Yes. Set the software interrupt flag.
V_MAX_REL_NOT_OFF ;**********************************************************
;******************************************************************************
; Assume [X1:X2] contains the offset period still.
; Next look at the code segments that can clear software interrupt flags.

	wrdswp	X1, X3			;x-x; [X1:X2] => [X3:X4]

	clrf	X1				;x-x; [0:VOLTAGE_HYST] => [X1:X2]
	banksel	V_HYST			;x-0;
	byteswp V_HYST, X2		;x-0; [V_HYST] -> [X2]

	bsf		PCLATH,3		;1-0; Service routines are on second prog. mem. page.
	call	SUB16			;1-0; [X3:X4] = [X3:X4]-[X1:X2] (voltage decreased by 
							;	hysteresis used to check minima)

	wrdswp	X3, X1			;1-0; [X3:X4] => [X1:X2]

							; [VOLTAGE]+[V_DIST_OFFSET]-[V_HYST]=[X1:X2]

;******************************************************************************	
V_MIN_STPT_ON ;**************************************************************
	; Assume [X1:X2] contains the offset voltage still with hysteresis.
	bsf		STATUS,RP0		;x-1;	
	bcf		PCLATH,3		;0-1; Program memory page 0.  
	btfss	V_INTERRUPT,7	;0-1; Is flag set?
	goto V_MIN_STPT_NOT_ON

	bcf		STATUS,RP0		;0-0;
	wrdswp	V_MIN_STPT, X3	;0-0; [V_MIN_STPT] => {X3:X4]

	bsf		PCLATH,3		;1-0; Service routines are on second prog. mem. page.
	call	SUB16			;1-0; [X3:X4] = [X3:X4]-[X1:X2] (signed)

	bcf		PCLATH,3		;0-0;
	bsf		STATUS,RP1		;0-2;
	btfsc	X3,7			;0-2;[VOLTAGE]+[V_DIST_OFFSET]-[V_HYST] 
							;0-2;	... ?>? [V_MIN_STPT]
; [VOLTAGE]+[V_DIST_OFFSET]-[V_HYST] > [V_MIN_STPT]
	goto	V_MIN_STPT_CONTINUE
; [VOLTAGE]+[V_DIST_OFFSET]-[V_HYST] </= [V_MIN_STPT]
	clrf	V_MIN_STPT_CNTR	;0-2; No. Clear the restart delay counter and end.	
	goto	V_MIN_STPT_NOT_ON

V_MIN_STPT_CONTINUE				; Yes. Test the restart delay counter.
	movf V_MIN_STPT_CNTR,W	;0-2; 
	subwf	V_RESTART_DLY,W	;0-2; Compare [V_RESTART_DLY] and [V_MIN_STPT_CNTR]
	banksel	V_INTERRUPT		;0-1;
	btfsc	STATUS,C		;0-1; [V_RESTART_DLY] ?<? [V_MIN_STPT_CNTR]
	btfsc	STATUS,Z		;0-1; [V_RESTART_DLY] ?=? [V_MIN_STPT_CNTR]
	bcf		V_INTERRUPT,7	;0-1;  Clear the software interrupt flag.
V_MIN_STPT_NOT_ON	;**********************************************************
;******************************************************************************

;******************************************************************************
V_MIN_REL_ON ;***************************************************************
	; Assume [X1:X2] contains the offset voltage still with hysteresis.	
	banksel	V_INTERRUPT		;x-1;
	bcf		PCLATH,3		;0-1; Program memory page 0.  
	btfss	V_INTERRUPT,5	;0-1; Is flag set?
	goto V_MIN_REL_NOT_ON

	wrdswp	V_MIN_REL, X3	;0-1; [V_MIN_REL] => [X3:X4]

	bsf		PCLATH,3		;1-1; Service routines are on second prog. mem. page.
	call	SUB16			;1-1; [X3:X4] = [X3:X4]-[X1:X2] (signed)

	bcf		PCLATH,3		;0-1;
	banksel	V_MIN_REL_CNTR	;0-2;
	btfsc	X3,7			;0-2; [VOLTAGE]+[V_DIST_OFFSET]-[V_HYST] 
							;0-2;	... ?>? [V_MIN_REL]
; [VOLTAGE]+[V_DIST_OFFSET]-[V_HYST] > [V_MIN_REL]
	goto	V_MIN_REL_CONTINUE
; [VOLTAGE]+[V_DIST_OFFSET]-[V_HYST] </= [V_MIN_REL]
	clrf	V_MIN_REL_CNTR	;0-2; No. Clear the restart delay counter and end.
	goto	V_MIN_REL_NOT_ON

V_MIN_REL_CONTINUE				; Yes. Test the restart delay counter.
	movf V_MIN_REL_CNTR,W	;0-2;
	subwf	V_RESTART_DLY,W	;0-2; Compare  [V_RESTART_DLY] and [V_MIN_REL_CNTR]
	banksel	V_INTERRUPT		;0-1;
	btfsc	STATUS,C		;0-1; [V_RESTART_DLY] ?<? [V_MIN_REL_CNTR]
	btfsc	STATUS,Z		;0-1; [V_RESTART_DLY] ?=? [V_MIN_REL_CNTR]
	bcf		V_INTERRUPT,5	;0-1; Yes. Clear the interrupt flag. 
V_MIN_REL_NOT_ON ;***********************************************************
;******************************************************************************

	; [X1:X2] = [VOLTAGE]+[V_DIST_OFFSET]-[V_HYST]

	wrdswp	X1, X3			;1; [X1:X2] => [X3:X4]

	bcf		STATUS,RP0		;0;
	clrf	X1				;0; [0:V_HYST] => [X1:X2]
	byteswp V_HYST, X2		;0; [V_HYST] -> [X2]

	bsf		PCLATH,3		;0; Service routines are on second prog. mem. page.
	call	ADD16			;0; [X3:X4] = [X3:X4]+[X1:X2] 

	bsf		PCLATH,3		;0; Service routines are on second prog. mem. page.
	call	ADD16			;0; [X3:X4] = [X3:X4]+[X1:X2]

	wrdswp	X3, X1			;0; [X3:X4] => [X1:X2]

					; [VOLTAGE]+[V_DIST_OFFSET]+[V_HYST]=[X1:X2]
					;	Now ready for comparison with maxima.

;******************************************************************************
V_MAX_STPT_ON ;**************************************************************
	; Assume [X1:X2] contains the offset voltage still with hysteresis.
	bsf		STATUS,RP0		;x-1;	
	bcf		PCLATH,3		;0-1; Program memory page 0.  
	btfss	V_INTERRUPT,6	;0-1; Is flag set?
	goto V_MAX_STPT_NOT_ON

	bcf		STATUS,RP0		;0-0;
	wrdswp	V_MAX_STPT, X3	;0-0; [V_MAX_STPT] => [X3:X4]

	bsf		PCLATH,3		;1-0; Service routines are on second prog. mem. page.
	call	SUB16			;1-0; [X3:X4] = [X3:X4]-[X1:X2] (signed)

	bcf		PCLATH,3		;0-1;
	bsf		STATUS,RP1		;0-2;
	btfss	X3,7			;0-2; [VOLTAGE]+[V_DIST_OFFSET]-[V_HYST] 
							;0-2;		... ?<? [V_MAX_STPT]
; [VOLTAGE]+[V_DIST_OFFSET]-[V_HYST] </= [V_MAX_STPT]
	goto	V_MAX_STPT_CONTINUE
; [VOLTAGE]+[V_DIST_OFFSET]-[V_HYST] > [V_MAX_STPT]
	clrf	V_MAX_STPT_CNTR	;0-2; No. Clear the restart delay counter and end.
	goto	V_MAX_STPT_NOT_ON

V_MAX_STPT_CONTINUE				; Yes. Test the restart delay counter.
	movf V_MAX_STPT_CNTR,W	;0-2; 
	subwf	V_RESTART_DLY,W	;0-2; Compare [V_RESTART_DLY] and [V_MAX_STPT_CNTR]
	banksel	V_INTERRUPT		;0-1;
	btfsc	STATUS,C		;0-1; [V_RESTART_DLY] ?<? [V_MAX_STPT_CNTR]
	btfsc	STATUS,Z		;0-1; [V_RESTART_DLY] ?=? [V_MAX_STPT_CNTR]
	bcf		V_INTERRUPT,6	;0-1; Yes. Clear interrupt flag.
V_MAX_STPT_NOT_ON ;**********************************************************
;******************************************************************************

;******************************************************************************
V_MAX_REL_ON ;***************************************************************
	; Assume [X1:X2] contains the offset voltage still with hysteresis.
	bcf		PCLATH,3		;0-x; Program memory page 0.
	banksel	V_INTERRUPT		;0-1;  
	btfss	V_INTERRUPT,4	;0-1; Is flag set?
	goto V_MAX_REL_NOT_ON

	wrdswp	V_MAX_REL, X3	;0-1; [V_MAX_REL] => [X3:X4]

	bsf		PCLATH,3		;1-1; Service routines are on second prog. mem. page.
	call	SUB16			;1-1; [X3:X4] = [X3:X4]-[X1:X2] (signed)

	bcf		PCLATH,3		;0-1;
	banksel	V_MAX_REL_CNTR	;0-2;
	btfss	X3,7			;0-2;[VOLTAGE]+[V_DIST_OFFSET]-[V_HYST] 
							;0-2;		... ?<? [V_MAX_REL]
; [VOLTAGE]+[V_DIST_OFFSET]-[V_HYST] </= [V_MAX_REL]
	goto	V_MAX_REL_CONTINUE
; [VOLTAGE]+[V_DIST_OFFSET]-[V_HYST] > [V_MAX_REL]
	clrf	V_MAX_REL_CNTR	;0-2; No. Clear the restart delay counter and end.
	goto	V_MAX_REL_NOT_ON

V_MAX_REL_CONTINUE				; Yes. Test the restart delay counter.
	movf V_MAX_REL_CNTR,W	;0-2; 
	subwf	V_RESTART_DLY,W	;0-2;
	banksel	V_INTERRUPT		;0-1;
	btfsc	STATUS,C		;0-1; [V_RESTART_DLY] ?<? [V_MAX_REL_CNTR]
	btfsc	STATUS,Z		;0-1; [V_RESTART_DLY] ?=? [V_MAX_REL_CNTR]
	bcf		V_INTERRUPT,4	;0-1; Yes. Clear the interrupt flag.
V_MAX_REL_NOT_ON ;***********************************************************
;******************************************************************************

END_GFA_VOLTAGE ;**************************************************************
;##############################################################################

;##############################################################################
GFA_EXTERNAL ;** Grid Friendly Chip External Signal Observation ***************
	banksel	EXT_FLAGS		;x-2;
	bcf		PCLATH,3		;0-2; Program memory page 0.  
	btfss	EXT_FLAGS,7		;0-2; Is a service request active? This flag is set
	goto	END_GFA_EXTERNAL    ;	periodically in RTC or directly by I2C.

	clrf	STATUS			;0-0;
	btfss	EXT_RESP_CONF,0	;0-0; (0 = from I2C; 1 = from A2D)
	goto	EXT_I2C

EXT_A2D 
	bsf		STATUS,RP1		;0-2;
	btfsc	EXT_FLAGS,6		;0-2; Is an A2D measurement waiting?
	goto	EXT_A2D_READ	    ; Yes. Capture the measured external variable.

	btfsc	EXT_FLAGS,4		;0-2; Have we been waiting for data acquisition?
	goto	EXT_START_A2D		; Yes. Start the A2D conversion.
	;No. Are we in the first half of a voltage acquisition cycle?

	bcf		STATUS,RP1		;0-0; Check that we are in first half of a voltage
	movlw	D'175'			;0-0; 	A2D acquisition period, meaning that TMR0
	subwf	TMR0,W			;0-0; 	is LESS than about 175 counts. This should be
	btfss	STATUS,C		;0-0;	enough time to squeeze another acquisition in.
	goto	END_GFA_EXTERNAL	;  	Otherwise, try again next time.
							
EXT_A2D_SETUP ;Prepare the A2D converter to take a measurement.
	clrf	STATUS			;0-0;
	movf	ADCON0,W		;0-0; Change from the voltage channel to the 
	iorlw	0x08			;0-0;  external variable channel.
	movwf	ADCON0			;0-0;
	bsf		STATUS,RP1		;0-2;
	bsf		EXT_FLAGS,4		;0-2; Set flag. We now wait a loop for data acq.
	goto	END_GFA_EXTERNAL	;  period to be completed. (more than necessary)

EXT_START_A2D ;Acquisition time should be complete. Start A2D conversion.
	clrf	STATUS			;0-0;
	bcf		PIR1,ADIF		;0-0; Make sure the A2D interrupt flag is cleared.
	bsf		ADCON0,2		;0-0; Start the A2D conversion process.
	bsf		STATUS,RP1		;0-2;
	bcf		EXT_FLAGS,4		;0-2; Clear flag. The data acquisition period is completed.
	bsf		EXT_FLAGS,5		;0-2; Set flag. We now await the A2D interrupt.
	goto	END_GFA_EXTERNAL

EXT_A2D_READ ;A external variable is available from the A2D converter.
	clrf	STATUS			;0-0; Read the A2D result into External variable.
	movf	ADRESH,W		;0-0; [ADRESH:ADRESL] -> [EXT;EXT+1]
	movwf	EXT				;0-0; (IMPORTANT NOTE: THIS ASSUMES THAT THE 
	bsf		STATUS,RP0		;0-1;	EXTERNAL VARIABLE HAS BEEN MOVED TO
	movf	ADRESL,W		;0-1;	BANK 0, WHERE IT IS ACCESSIBLE TO I2C 
	bcf		STATUS,RP0		;0-0;	WRITES.)
	movwf	EXT+1			;0-0;

EXT_A2D_TEARDOWN ;Return A2D converter to voltage measurements.
	;Code to change A2D channel back to voltage readings.
	clrf	STATUS			;0-0;
	movf	ADCON0,W		;0-0; Change from the external variable channel to the 
	andlw	0xF7			;0-0;  voltage channel.
	movwf	ADCON0			;0-0;
	bsf		STATUS,RP1		;0-2;
	bcf		EXT_FLAGS,6		;0-2; Clear flag. Ready for next external variable event.

EXT_I2C ; External signal was obtained via I2C communication or by A2D.
	clrf	STATUS			;0-0; (EXT moved to bank 0)
	wrdswp	EXT, X3			;0-0; [EXT] => [X3:X4]

EXTERNAL_FLAGS	; Set external signal condition flags here. Note that this 
				;	section addresses only the condition and never the 
				;	responses.
				; NOTE: At this starting point, [X3:X4] = [EXT]

	bsf		STATUS,RP1		 ;2;
	clrf	X1		  		;2; [{sign bits}:EXT_DIST_OFFSET] => [X1:X2]
	btfsc	EXT_DIST_OFFSET,7 ;2;
	decf	X1,F		  	;2;
	byteswp	EXT_DIST_OFFSET, X2	;2; [EXT_DIST_OFFSET] -> [X2]

	bsf		PCLATH,3		;2; Service routines are on second prog. mem. page.
	call	ADD16 			;2; [X3:X4] = [X3:X4] + [X1:X2] (offset [EXT])

	wrdswp	X3, X1			;2; [X3:X4] => [X1:X2]

	; Now [EXT] + [EXT_DIST_OFFSET] = [X1:X2]	

;******************************************************************************
EXT_MIN_STPT_OFF ;*************************************************************
	; Assume [X1:X2] contains the offset external signal still.
	banksel	EXT_INTERRUPT	;x-1;	
	bcf		PCLATH,3		;0-1; Program memory page 0.  
	btfsc	EXT_INTERRUPT,7	;0-1; Is flag set?
	goto EXT_MIN_STPT_NOT_OFF

	bcf		STATUS,RP0		;0-0;
	wrdswp	EXT_MIN_STPT, X3 ;0-0; [EXT_MIN_STPT] => {X3:X4]

	bsf		PCLATH,3		;1-0; Service routines are on second prog. mem. page.
	call	SUB16			;1-0; [X3:X4] = [X3:X4]-[X1:X2] (signed)
	
	bcf		PCLATH,3		;0-0;
	bsf		STATUS,RP1		;0-2;
	btfss	X3,7		  	;0-2; [EXT]+[EXT_DIST_OFFSET] ?<? [EXT_MIN_STPT]
; [EXT]+[EXT_DIST_OFFSET] </= [EXT_MIN_STPT]
	goto	EXT_MIN_STPT_CONTINUE2
; [EXT]+[EXT_DIST_OFFSET] > [EXT_MIN_STPT]
	clrf	E_MIN_SP_SU_CNTR	;0-2; No. Clear the startup counter and end.
	goto	EXT_MIN_STPT_NOT_OFF

EXT_MIN_STPT_CONTINUE2				; Yes. Test the startup counter.
	movf	E_MIN_SP_SU_CNTR,W	;0-2;
	bcf		STATUS,RP1			;0-0;
	subwf	EXT_STARTUP_DLY,W	;0-0; Compare [E_MIN_SP_SU_CNTR] and [EXT_STARTUP_DLY]
	bsf		STATUS,RP0			;0-1;
	btfsc	STATUS,C			;0-1; [E_MIN_SP_SU_CNTR] ?>? [EXT_STARTUP_DLY]
	btfsc	STATUS,Z			;0-1; [E_MIN_SP_SU_CNTR] ?=? [EXT_STARTUP_DLY]
	bsf		EXT_INTERRUPT,7		;0-1; Yes. Set the software interrupt flag.
EXT_MIN_STPT_NOT_OFF ;*********************************************************
;******************************************************************************

;******************************************************************************
EXT_MAX_STPT_OFF ;*************************************************************
	; Assume [X1:X2] contains the offset external signal still.
	bcf		PCLATH,3		;0-x; Program memory page 0.  
	banksel	EXT_INTERRUPT	;0-1;
	btfsc	EXT_INTERRUPT,6	;0-1; Is flag set?
	goto EXT_MAX_STPT_NOT_OFF

	bcf		STATUS,RP0		;0-0;
	wrdswp	EXT_MAX_STPT, X3 ;0-0; [EXT_MAX_STPT] => [X3:X4]

	bsf		PCLATH,3		;1-0; Service routines are on second prog. mem. page.
	call	SUB16			;1-0; [X3:X4] = [X3:X4]-[X1:X2] (signed)

	bcf		PCLATH,3		;0-0;
	bsf		STATUS,RP1		;0-2;
	btfsc	X3,7		  	;0-2; [EXT]+[EXT_DIST_OFFSET] ?>? [EXT_MAX_STPT]
; [EXT]+[EXT_DIST_OFFSET] > [EXT_MAX_STPT]
	goto EXT_MAX_STPT_CONTINUE2
; [EXT]+[EXT_DIST_OFFSET] </= [EXT_MAX_STPT]
	clrf	E_MAX_SP_SU_CNTR	;0-2; No. Clear the startup counter and end.
	goto 	EXT_MAX_STPT_NOT_OFF

EXT_MAX_STPT_CONTINUE2			; Yes. Test the startup counter.
	movf	E_MAX_SP_SU_CNTR,W	;0-2;
	bcf		STATUS,RP1			;0-0;
	subwf	EXT_STARTUP_DLY,W	;0-0; Compare [E_MAX_SP_SU_CNTR] and [EXT_STARTUP_DLY].
	bsf		STATUS,RP0			;0-1;
	btfsc	STATUS,C			;0-1; [E_MAX_SP_SU_CNTR] ?>? [EXT_STARTUP_DLY].
	btfsc	STATUS,Z			;0-1; [E_MAX_SP_SU_CNTR] ?=? [EXT_STARTUP_DLY].
	bsf		EXT_INTERRUPT,6		;0-1; Yes. Set the software interrupt flag.
EXT_MAX_STPT_NOT_OFF ;*********************************************************
;******************************************************************************

;******************************************************************************
EXT_MIN_REL_OFF ;**************************************************************
	; Assume [X1:X2] contains the offset external signal still.
	bcf		PCLATH,3		;0-x; Program memory page 0.  
	banksel	EXT_INTERRUPT	;0-1;
	btfsc	EXT_INTERRUPT,5	;0-1; Is flag set?
	goto EXT_MIN_REL_NOT_OFF 

	wrdswp	EXT_MIN_REL, X3	;0-1; [EXT_MIN_REL] => [X3:X4]

	bsf		PCLATH,3		;1-1; Service routines are on second prog. mem. page.
	call	SUB16			;1-1; [X3:X4] = [X3:X4]-[X1:X2] (signed)

	bcf		PCLATH,3		;0-1;
	banksel	E_MIN_REL_SU_CNTR	;0-2;
	btfss	X3,7		 	;0-2; [EXT]+[EXT_DIST_OFFSET] ?<? [EXT_MIN_REL]
; [EXT]+[EXT_DIST_OFFSET] </= [EXT_MIN_REL]
	goto	EXT_MIN_REL_CONTINUE2
; [EXT]+[EXT_DIST_OFFSET] > [EXT_MIN_REL]
	clrf	E_MIN_REL_SU_CNTR	;0-2; No. Clear the startup counter and end.
	goto	EXT_MIN_REL_NOT_OFF

EXT_MIN_REL_CONTINUE2				; Yes. Test the startup counter.
	movf	E_MIN_REL_SU_CNTR,W	;0-2;
	bcf		STATUS,RP1			;0-0;
	subwf	EXT_STARTUP_DLY,W	;0-0; Compare [E_MIN_REL_SU_CNTR] and [EXT_STARTUP_DLY]
	bsf		STATUS,RP0			;0-1;
	btfsc	STATUS,C			;0-1; [E_MIN_REL_SU_CNTR] ?>? [EXT_STARTUP_DLY]
	btfsc	STATUS,Z			;0-1; [E_MIN_REL_SU_CNTR] ?=? [EXT_STARTUP_DLY]
	bsf		EXT_INTERRUPT,5		;0-1; Yes. Set the software interrupt flag.
EXT_MIN_REL_NOT_OFF	;**********************************************************
;******************************************************************************

;******************************************************************************
EXT_MAX_REL_OFF ;**************************************************************
	; Assume [X1:X2] contains the offset extnal signal still.
	bcf		PCLATH,3		;0-x; Program memory page 0.  
	banksel	EXT_INTERRUPT	;0-1;
	btfsc	EXT_INTERRUPT,4	;0-1; Is flag set?
	goto EXT_MAX_REL_NOT_OFF

	wrdswp	EXT_MAX_REL, X3	;0-1; [EXT_MAX_REL] => [X3:X4]

	bsf		PCLATH,3		;1-1; Service routines are on second prog. mem. page.
	call	SUB16			;1-1; [X3:X4] = [X3:X4]-[X1:X2] (signed)

	bcf		PCLATH,3		;0-1;
	banksel	E_MAX_REL_SU_CNTR	;0-2;
	btfsc	X3,7			;0-2; [EXT]+[EXT_DIST_OFFSET] ?>? [EXT_MAX_REL]
; [EXT]+[EXT_DIST_OFFSET] > [EXT_MAX_REL]
	goto	EXT_MAX_REL_CONTINUE2
; [EXT]+[EXT_DIST_OFFSET] </= [EXT_MAX_REL]	
	clrf	E_MAX_REL_SU_CNTR	;0-2; No. Clear the startup counter and end.
	goto	EXT_MAX_REL_NOT_OFF

EXT_MAX_REL_CONTINUE2				; Yes. Test the startup counter.
	movf	E_MAX_REL_SU_CNTR,W	;0-2; 
	bcf		STATUS,RP1			;0-0;
	subwf	EXT_STARTUP_DLY,W	;0-0; Compare [E_MAX_REL_SU_CNTR] and [EXT_STARTUP_DLY].
	bsf		STATUS,RP0			;0-1;
	btfsc	STATUS,C			;0-1; [E_MAX_REL_SU_CNTR] ?>? [EXT_STARTUP_DLY]
	btfsc	STATUS,Z			;0-1; [E_MAX_REL_SU_CNTR] ?=? [EXT_STARTUP_DLY]
	bsf		EXT_INTERRUPT,4	;0-1; Yes. Set the software interrupt flag.
EXT_MAX_REL_NOT_OFF ;**********************************************************
;******************************************************************************

; Next look at the code segments that can clear software interrupt flags.

	wrdswp	X1, X3			;x-x; [X1:X2] => [X3:X4]

	clrf	X1				;x-x; [0:EXT_HYST] => [X1:X2]
	banksel	EXT_HYST		;x-0;
	byteswp EXT_HYST, X2	;x-0; [EXT_HYST] -> [X2]

	bsf		PCLATH,3		;1-0; Service routines are on second prog. mem. page.
	call	SUB16			;1-0; [X3:X4] = [X3:X4]-[X1:X2] 
		; (voltage decreased by hysteresis used to check minima)

	wrdswp	X3, X1			;1-0; [X3:X4] => [X1:X2]

		; [EXT]+[EXT_DIST_OFFSET]-[EXT_HYST]=[X1:X2]

;******************************************************************************	
EXT_MIN_STPT_ON ;**************************************************************
	; Assume [X1:X2] contains the offset external signal still with hyst.
	banksel	EXT_INTERRUPT	;x-1;	
	bcf		PCLATH,3		;0-1; Program memory page 0.  
	btfss	EXT_INTERRUPT,7	;0-1; Is flag set?
	goto EXT_MIN_STPT_NOT_ON

	bcf		STATUS,RP0		;0-0;
	wrdswp	EXT_MIN_STPT, X3 ;0-0; [EXT_MIN_STPT] => [X3:X4]

	bsf		PCLATH,3		;1-0; Service routines are on second prog. mem. page.
	call	SUB16			;1-0; [X3:X4] = [X3:X4]-[X1:X2] (signed)

	bcf		PCLATH,3		;0-0;
	bsf		STATUS,RP1		;0-2;
	btfsc	X3,7			;0-2; [EXT]+[EXT_DIST_OFFSET]-[EXT_HYST] 
							;0-2;	... ?>? [EXT_MIN_STPT]
; [EXT]+[EXT_DIST_OFFSET]-[EXT_HYST] > [EXT_MIN_STPT]
	goto	EXT_MIN_STPT_CONTINUE
; [EXT]+[EXT_DIST_OFFSET]-[EXT_HYST] </= [EXT_MIN_STPT]
	clrf	EXT_MIN_STPT_CNTR ;0-2; No. Clear the restart delay counter and end.
	goto 	EXT_MIN_STPT_NOT_ON

EXT_MIN_STPT_CONTINUE			; Test the restart delay counter.
	movf EXT_MIN_STPT_CNTR,W ;0-2; 
	subwf	EXT_RESTART_DLY,W ;0-2; compare [EXT_RESTART_DLY] and [EXT_MIN_STPT_CNTR]
	banksel	EXT_INTERRUPT	;0-1;
	btfsc	STATUS,C		;0-1; [EXT_RESTART_DLY] ?<? [EXT_MIN_STPT_CNTR]
	btfsc	STATUS,Z		;0-1; [EXT_RESTART_DLY] ?=? [EXT_MIN_STPT_CNTR]
	bcf		EXT_INTERRUPT,7	;0-1;  Clear the software interrupt flag.
EXT_MIN_STPT_NOT_ON	;**********************************************************
;******************************************************************************

;******************************************************************************
EXT_MIN_REL_ON ;***************************************************************
	; Assume [X1:X2] contains the offset external signal still with hyst.
	; Assume we are still in bank 1
	banksel	EXT_INTERRUPT	;x-1;
	bcf		PCLATH,3		;0-1; Program memory page 0.  
	btfss	EXT_INTERRUPT,5	;0-1; Is flag set?
	goto EXT_MIN_REL_NOT_ON	

	wrdswp	EXT_MIN_REL, X3	;0-1; [EXT_MIN_REL] => [X3:X4]

	bsf		PCLATH,3		;1-1; Service routines are on second prog. mem. page.
	call	SUB16			;1-1; [X3:X4] = [X3:X4]-[X1:X2] (signed)

	bcf		PCLATH,3		;0-1;
	banksel	EXT_MIN_REL_CNTR ;0-2;
	btfsc	X3,7			;0-2;[EXT]+[EXT_DIST_OFFSET]-[EXT_HYST] 
							;0-2;	... ?>? [EXT_MIN_REL]
; [EXT]+[EXT_DIST_OFFSET]-[EXT_HYST] > [EXT_MIN_REL]
	goto	EXT_MIN_REL_CONTINUE
; [EXT]+[EXT_DIST_OFFSET]-[EXT_HYST] </= [EXT_MIN_REL]
	clrf	EXT_MIN_REL_CNTR ;0-2; No. Clear the restart delay counter and end.
	goto	EXT_MIN_REL_NOT_ON
	
EXT_MIN_REL_CONTINUE			; Yes. Test the restart delay counter.
	movf EXT_MIN_REL_CNTR,W	;0-2; 
	subwf	EXT_RESTART_DLY,W ;0-2; compare  [EXT_RESTART_DLY] and [EXT_MIN_REL_CNTR]
	banksel	EXT_INTERRUPT	;0-1;
	btfsc	STATUS,C		;0-1; [EXT_RESTART_DLY] ?<? [EXT_MIN_REL_CNTR]
	btfsc	STATUS,Z		;0-1; [EXT_RESTART_DLY] ?=? [EXT_MIN_REL_CNTR]
	bcf		EXT_INTERRUPT,5	;0-1; Yes. Clear the interrupt flag. 
EXT_MIN_REL_NOT_ON ;***********************************************************
;******************************************************************************

	; [X1:X2] = [EXT]+[EXT_DIST_OFFSET]-[EXT_HYST]

	wrdswp	X1, X3			;x-x; [X1:X2] => [X3:X4]

	banksel	EXT_HYST		;x-0;
	clrf	X1				;x-0; [0:EXT_HYST] => [X1:X2]
	byteswp EXT_HYST, X2	;x-0; [EXT_HYST] -> [X2]

	bsf		PCLATH,3		;1-0; Service routines are on second prog. mem. page.
	call	ADD16			;1-0; [X3:X4] = [X3:X4]+[X1:X2] 

	bsf		PCLATH,3		;1-0; Service routines are on second prog. mem. page.
	call	ADD16			;1-0; [X3:X4] = [X3:X4]+[X1:X2]

	wrdswp	X3, X1			;1-0; [X3:X4] => [X1:X2]


		; [EXT]+[EXT_DIST_OFFSET]+[EXT_HYST]=[X1:X2]
		;	Now ready for comparison with maxima.

;******************************************************************************
EXT_MAX_STPT_ON ;**************************************************************
	; Assume [X1:X2] contains the offset external signal still with hyst.
	bsf		STATUS,RP0		;x-1;	
	bcf		PCLATH,3		;0-1; Program memory page 0.  
	btfss	EXT_INTERRUPT,6	;0-1; Is flag set?
	goto EXT_MAX_STPT_NOT_ON

	bcf		STATUS,RP0		;0-0;
	wrdswp	EXT_MAX_STPT, X3 ;0-0; [EXT_MAX_STPT] => [X3:X4]

	bsf		PCLATH,3		;1-0; Service routines are on second prog. mem. page.
	call	SUB16			;1-0; [X3:X4] = [X3:X4]-[X1:X2] (signed)

	bcf		PCLATH,3		;0-0;
	bsf		STATUS,RP1		;0-2;
	btfss	X3,7			;0-2;[EXT]+[EXT_DIST_OFFSET]-[EXT_HYST] 
							;0-2;		... ?<? [EXT_MAX_STPT]
; [EXT]+[EXT_DIST_OFFSET]-[EXT_HYST] </= [EXT_MAX_STPT]
	goto	EXT_MAX_STPT_CONTINUE
; [EXT]+[EXT_DIST_OFFSET]-[EXT_HYST] > [EXT_MAX_STPT]
	clrf	EXT_MAX_STPT_CNTR ;0-2;	No. Clear the restart delay counter and end.
	goto	EXT_MAX_STPT_NOT_ON

EXT_MAX_STPT_CONTINUE			; Yes. Test the restart delay counter.
	movf EXT_MAX_STPT_CNTR,W ;0-2; 
	subwf	EXT_RESTART_DLY,W ;0-2; compare [EXT_RESTART_DLY] and [EXT_MAX_STPT_CNTR]
	banksel	EXT_INTERRUPT	;0-1;
	btfsc	STATUS,C		;0-1; [EXT_RESTART_DLY] ?<? [EXT_MAX_STPT_CNTR]
	btfsc	STATUS,Z		;0-1; [EXT_RESTART_DLY] ?=? [EXT_MAX_STPT_CNTR]
	bcf		EXT_INTERRUPT,6	;0-1; Yes. Clear interrupt flag.
EXT_MAX_STPT_NOT_ON ;**********************************************************
;******************************************************************************

;******************************************************************************
EXT_MAX_REL_ON ;***************************************************************
	; Assume [X1:X2] contains the offset external signal still with hyst.
	; Assume we are still in bank 1
	bcf		PCLATH,3		;0-x; Program memory page 0. 
	banksel	EXT_INTERRUPT	;0-1; 	
	btfss	EXT_INTERRUPT,4	;0-1; Is flag set?
	goto EXT_MAX_REL_NOT_ON	

	wrdswp	EXT_MAX_REL, X3	;0-1; [EXT_MAX_REL] => {X3:X4]

	bsf		PCLATH,3		;1-1; Service routines are on second prog. mem. page.
	call	SUB16			;1-1; [X3:X4] = [X3:X4]-[X1:X2] (signed)

	bcf		PCLATH,3		;0-1;
	banksel	EXT_MAX_REL_CNTR ;0-2;
	btfss	X3,7			;0-2;[EXT]+[EXT_DIST_OFFSET]-[EXT_HYST] 
							;0-2;		... ?<? [EXT_MAX_REL]
; [EXT]+[EXT_DIST_OFFSET]-[EXT_HYST] </= [EXT_MAX_REL]
	goto	EXT_MAX_REL_CONTINUE
; [EXT]+[EXT_DIST_OFFSET]-[EXT_HYST] > [EXT_MAX_REL]
	clrf	EXT_MAX_REL_CNTR ;0-2; No. Clear the restart delay counter and end.
	goto	EXT_MAX_REL_NOT_ON

EXT_MAX_REL_CONTINUE			; Yes. Test the restart delay counter.
	movf EXT_MAX_REL_CNTR,W	;0-2; 
	subwf	EXT_RESTART_DLY,W ;0-2; Compare [EXT_RESTART_DLY] and [EXT_MAX_REL_CNTR]
	banksel	EXT_INTERRUPT	;0-1;
	btfsc	STATUS,C		;0-1; [EXT_RESTART_DLY] ?<? [EXT_MAX_REL_CNTR]
	btfsc	STATUS,Z		;0-1; [EXT_RESTART_DLY] ?=? [EXT_MAX_REL_CNTR]
	bcf		EXT_INTERRUPT,4	;0-1; Yes. Clear the interrupt flag.
EXT_MAX_REL_NOT_ON ;***********************************************************
;******************************************************************************
	
	banksel	EXT_FLAGS		;0-2;
	bcf		EXT_FLAGS,7		;0-2; Clear flag. External variable has been serviced.

END_GFA_EXTERNAL ;*************************************************************
;##############################################################################

;##############################################################################
GFA_RESPONSE ;** Grid Friendly Chip Responses *********************************

;******************************************************************************
DEFAULT_REGULATION_THRESHOLDS ;************************************************
; By default, the absolute thresholds are used for regulation services. This
; permits one to reassign either threshold type independently in application-
; specific code.
;[PER_MAX_STPT] => [PER_MAX_REG]
	clrf	STATUS				;0-0;
	movf	PER_MAX_STPT,W		;0-0;
	bsf		STATUS,RP1			;0-2;
	movwf	PER_MAX_REG			;0-2;
	bcf		STATUS,RP1			;0-0;
	movf	PER_MAX_STPT+1,W	;0-0;
	bsf		STATUS,RP1			;0-2;
	movwf	PER_MAX_REG+1		;0-2;
;[PER_MIN_STPT] => [PER_MIN_REG]
	clrf	STATUS				;0-0;
	movf	PER_MIN_STPT,W		;0-0;
	bsf		STATUS,RP1			;0-2;
	movwf	PER_MIN_REG			;0-2;
	bcf		STATUS,RP1			;0-0;
	movf	PER_MIN_STPT+1,W	;0-0;
	bsf		STATUS,RP1			;0-2;
	movwf	PER_MIN_REG+1		;0-2;
;[V_MAX_STPT] => [V_MAX_REG]
	clrf	STATUS				;0-0;
	movf	V_MAX_STPT,W		;0-0;
	bsf		STATUS,RP1			;0-2;
	movwf	V_MAX_REG			;0-2;
	bcf		STATUS,RP1			;0-0;
	movf	V_MAX_STPT+1,W		;0-0;
	bsf		STATUS,RP1			;0-2;
	movwf	V_MAX_REG+1			;0-2;
;[V_MIN_STPT] => [V_MIN_REG]
	clrf	STATUS				;0-0;
	movf	V_MIN_STPT,W		;0-0;
	bsf		STATUS,RP1			;0-2;
	movwf	V_MIN_REG			;0-2;
	bcf		STATUS,RP1			;0-0;
	movf	V_MIN_STPT+1,W		;0-0;
	bsf		STATUS,RP1			;0-2;
	movwf	V_MIN_REG+1			;0-2;
;[EXT_MAX_STPT] => [EXT_MAX_REG]
	clrf	STATUS				;0-0;
	movf	EXT_MAX_STPT,W		;0-0;
	bsf		STATUS,RP1			;0-2;
	movwf	EXT_MAX_REG			;0-2;
	bcf		STATUS,RP1			;0-0;
	movf	EXT_MAX_STPT+1,W	;0-0;
	bsf		STATUS,RP1			;0-2;
	movwf	EXT_MAX_REG+1		;0-2;
;[EXT_MIN_STPT] => [EXT_MIN_REG]
	clrf	STATUS				;0-0;
	movf	EXT_MIN_STPT,W		;0-0;
	bsf		STATUS,RP1			;0-2;
	movwf	EXT_MIN_REG			;0-2;
	bcf		STATUS,RP1			;0-0;
	movf	EXT_MIN_STPT+1,W	;0-0;
	bsf		STATUS,RP1			;0-2;
	movwf	EXT_MIN_REG+1		;0-2;
END_DEFAULT_REGULATION_THRESHOLDS ;********************************************
;******************************************************************************

;##############################################################################
USER_APPLICATION_FUNCTIONS ; This code area provided for more complex functional
; responses that cannot be accommodated by the existing structure.
; Created separate protected bytes [PER_MAX_REG] and [PER_MIN_REG] so that 
; both UFLS and frequency regulation are possible in same application on 11/5/09.
; Regulating Water Heater Controller Function:
; [EXT] contains water heater temperature: 
;	TEMPERATURE		[EXT]				[PER_MIN_REG]		[PER_MAX_REG]
;	54.5 C (130 F) 	365[-256=109]		60.05 Hz = 20,816	60.05 Hz = 20,816
;					<27>				<0>					<14>
;	48.9 C (120 F)	338[-256=82]		60.05 Hz = 20,816	60.011Hz = 20,830
;					<28>				<0>					<21>
;	43.3 C (110 F)	310[-256=54]		60.05 Hz = 20,816	59.95 Hz = 20,851
;					<26>				<0>					<353>
;	37.8 C (100 F)	284[-256=28]		60.05 Hz = 20,816	58.95 Hz = 21,204
	constant FREQMINHB=0x7F ; This is the period count of the minimum frequency 
	constant FREQMINLB=0xFF ;  (~38.5 Hz) allowed in my unsigned math comparisons. 
	constant FREQ59_95HB=D'81'
 	constant FREQ59_95LB=D'115'
	constant FREQ60_011HB=D'81'
 	constant FREQ60_011LB=D'94'
 	constant FREQ60_05HB=D'81'
 	constant FREQ60_05LB=D'80'
	constant EXT120=D'338'-D'256';=82
	constant EXT110=D'310'-D'256';=54

; If the high byte of [EXT] is 1, this is a normal range. Otherwise, turn full on.
	clrf	STATUS			;x-0;
	bcf		PCLATH,3		;0-0;
	movlw	0x1				;0-0;
	subwf	EXT,W			;0-0;
	btfss	STATUS,Z		;0-0;
	goto	FULL_ON
	clrf	X1				;0-0; This scratch byte will be used for word subtraction.

; If water is heated over 120 F (i.e., [EXT] > 338,
;	[PER_MAX_REG] = 20,830 - ([EXT]-338) / 2
; 
;	NOTE: division by 2 in this function approximates mult. by 14/27.

	movlw	EXT120 			;0-0; If ([EXT] - 256) >/= (120 F - 256),
	subwf	EXT+1,W			;0-0;   
	movwf	X2				;0-0;
	btfss	STATUS,C		;0-0;
	goto 	NOT_OVER120

OVER120
	movlw	FREQ60_011HB	;0-0; Period 60.011 Hz --> [x3:x4]
	movwf	X3				;0-0;
	movlw	FREQ60_011LB	;0-0;
	movwf	X4				;0-0;

	bcf		STATUS,C		;0-0; [x2] = [x2]/2
	rrf		X2,F			;0-0;

	bsf		PCLATH,3		;1-0;
	call	SUB16			;1-0; [X3:X4] = [X3:X4]-[0:X2] (signed)

	bsf		STATUS,RP1		;1-2;
	wrdswp	X3,PER_MAX_REG	;1-2; [x3:x4] -> [PER_MAX_REG]

	bcf		PCLATH,3		;0-2;
	goto DONE_USER_APPLICATION_FUNCTIONS

NOT_OVER120
; If water is heated over 110 F (i.e., [EXT] > 310,
;	[PER_MAX_REG] = 20,851 - ([EXT]-310) + ([EXT]-310)/4
;	NOTE: the math of this function approximates the factor 21/28 = 3/4.
	movlw	EXT110 			;0-0; If ([EXT] - 256) >= (110 F - 256),
	subwf	EXT+1,W			;0-0;   
	movwf	X2				;0-0;
	btfss	STATUS,C		;0-0;
	goto 	NOT_OVER110

OVER110
	movlw	FREQ59_95HB		;0-0; Period 59.95 Hz --> [x3:x4]
	movwf	X3				;0-0;
	movlw	FREQ59_95LB		;0-0;
	movwf	X4				;0-0;

	bsf		PCLATH,3		;1-0;
	call	SUB16			;1-0; [X3:X4] = [X3:X4]-[0:X2] (signed)

	bcf		STATUS,C		;1-0; Add back 1/4 the difference
	rrf		X2,F			;1-0;
	bcf		STATUS,C		;1-0;
	rrf		X2,F			;1-0;

	call	ADD16			;1-0; [X3:X4] = [X3:X4]+[0:X2]

	bsf		STATUS,RP1		;1-2;
	wrdswp	X3,PER_MAX_REG	;1-2; [x3:x4] -> [PER_MAX_REG]

	bcf		PCLATH,3		;0-2;
	goto DONE_USER_APPLICATION_FUNCTIONS

NOT_OVER110
; Otherwise, water must be below 110 F (i.e., [EXT] < 310,
;	[PER_MAX_REG] = 20,851 + (310-[EXT])*16
; Calculation begins with negative difference 
;  			([EXT] - 256) > (110 F - 256) in [X2].
	movlw	FREQ59_95HB		;0-0; Period 59.95 Hz --> [x3:x4]
	movwf	X3				;0-0;
	movlw	FREQ59_95LB		;0-0;
	movwf	X4				;0-0;

	swapf	X2,W			;0-0; [x1:x2] = [x1:x2]*16
	movwf	X1				;0-0;
	movwf	X2				;0-0;
	movlw	0xF0			;0-0;
	iorwf	X1,F			;0-0;
	andwf	X2,F			;0-0;

	bsf		PCLATH,3		;1-0;
	call	SUB16			;1-0; [X3:X4] = [X3:X4]-[0:X2] (signed)

	bsf		STATUS,RP1		;1-2;
	wrdswp	X3,PER_MAX_REG	;1-2; [x3:x4] -> [PER_MAX_REG]

	bcf		PCLATH,3		;0-2;
	goto DONE_USER_APPLICATION_FUNCTIONS

FULL_ON; Set high period threshold at 38.5 Hz ([PER_MAX_REG]=41,667)
	banksel	PER_MAX_REG		;0-2;
	movlw	FREQMINHB		;0-2; [PER_MAX_REG] = period of 38.5 Hz to achieve full on.
	movwf	PER_MAX_REG		;0-2;
	movlw	FREQMINLB		;0-2;
	movwf	PER_MAX_REG+1	;0-2;

DONE_USER_APPLICATION_FUNCTIONS
	banksel	PER_MIN_REG		;0-2;
	movlw	FREQ60_05HB		;0-2; Period 60.05 Hz -> [PER_MIN_REG]
	movwf	PER_MIN_REG		;0-2;
	movlw	FREQ60_05LB		;0-2;
	movwf	PER_MIN_REG+1	;0-2;

END_USER_APPLICATION_FUNCTIONS ;***********************************************
;##############################################################################

;##############################################################################
PERIOD_RESPONSE	;**************************************************************

;******************************************************************************
PER_HW_INT_CHECK ;** Period Hardware Interrupt Service Check ******************
; Compare period interrupts and period hardware interrupt mask.
	clrf	STATUS			;x-0; 
	movf	PER_INT_HW_MASK,W ;x-0;	
	bsf		STATUS,RP0		;x-1;
	andwf	PER_INTERRUPT,W	;x-1;
	bcf		PCLATH,3		;0-1; Program memory page 0.  
	btfsc	STATUS,Z		;0-1; Should a period HW interrupt be indicated?
	goto 	NO_PER_HW_INTS	;0-1;	No.

YES_PER_HW_INTS				;0-1; Yes. Activate the _period interrupt pin.
; Change _INT_F and _INT_MSTR pins to outputs.
	movlw	_INT_F_BYTE		;0-1; [1111 1011] -> [WREG]
	andlw	_INT_MSTR_BYTE	;0-1; [1111 1010] -> [WREG]
	andwf	TRISB,W			;0-1; [TRISB<uuuu uxux>] -> [TRIS<uuuu u0u0>]
	iorlw	PB_PROTECT		;0-1; Protect the I2C pins -> [TRISB<uuu1 u010>]
	movwf	TRISB			;0-1;
; Set central hardware interrupt flag.
	bsf		INTERRUPTS,0	;0-1;
; Set _INT_F PORTB pin output buffer low.
	bcf		STATUS,RP0		;0-0; 
	bcf		PORTB,_INT_F	;0-0;  [PORTB<uuuu uxuu>] -> [PORTB<uuuu u0uu>]
; Set the _INT_MSTR pin output buffer low.
	bcf		PORTB,_INT_MSTR	;0-0; [PORTB<uuuu uuux>] -> [PORTB<uuuu uuu0>]
; Done. Pin states have been modified for interrupt status.
	bcf		PCLATH,3		;0-0; Program memory page 0.  
	goto	END_PER_HW_INT_CHECK 

NO_PER_HW_INTS				;0-1; No. 
; Deactivate the period interrupt pin.
	bcf		INTERRUPTS,0	;0-1;  Clear the central hardware interrupt flag
; Set the _INT_F pin as an input (pulled high).
	movlw	INT_F_BYTE		;0-1; [0000 0100] -> [WREG]
	iorwf	TRISB,W			;0-1; [TRISB<uuuu uxuu>] -> [TRIS<uuuu u1uu>]
	iorlw	PB_PROTECT		;0-1; Protect the I2C pins -> [TRISB<uuu1 u11u>]
	movwf	TRISB			;0-1;

END_PER_HW_INT_CHECK ;*********************************************************
;******************************************************************************

END_PERIOD_RESPONSE	;**********************************************************
;##############################################################################

;##############################################################################
VOLTAGE_RESPONSE ;*************************************************************

;******************************************************************************
V_HW_INT_CHECK ;** Period Hardware Interrupt Service Check ********************
; Compare voltage interrupts and voltage hardware interrupt mask.
	clrf	STATUS			;x-0; 
	movf	V_INT_HW_MASK,W	;x-0;	
	bsf		STATUS,RP0		;x-1;
	andwf	V_INTERRUPT,W	;x-1;
	bcf		PCLATH,3		;0-1; Program memory page 0.  
	btfsc	STATUS,Z		;0-1; Should a voltage HW interrupt be indicated?
	goto 	NO_V_HW_INTS	;0-1; No.

YES_V_HW_INTS				;0-1; Yes. Activate the voltage interrupt pin.
; Change _INT_V and INT_MSTR pins to outputs. (Active output low)
	movlw	_INT_V_BYTE		;0-1; [1101 1111] -> [WREG]
	andlw	_INT_MSTR_BYTE	;0-1; [1101 1110] -> [WREG]
	andwf	TRISB,W			;0-1; [TRISB<uuxu uuuu>] -> [TRIS<uu0u uuu0>]
	iorlw	PB_PROTECT		;0-1; Protect the I2C pins -> [TRISB<uu01 uu10>]
	movwf	TRISB			;0-1;
; Set central hardware interrupt flag.
	bsf		INTERRUPTS,1	;0-1;	
; Set _INT_V PORTB pin low.
	bcf		STATUS,RP0		;0-0; 
	bcf		PORTB,_INT_V	;0-0; [PORTB<uuxu uuuu>] -> [PORTB<uu0u uuuu>]
; Set _INT_MSTR PORTB pin low.
	bcf		PORTB,_INT_MSTR	;0-0; [PORTB<uuuu uuux>] -> [PORTB<uuuu uuu0>]
; Done. Pins have been modified to reflect voltage interrupts.
	bcf		PCLATH,3		;0-0; Program memory page 0.  
	goto	END_V_HW_INT_CHECK

NO_V_HW_INTS				;0-1; No. Deactivate the _voltage interrupt pin.
; Clear the central hardware interrupt flag
	bcf		INTERRUPTS,1	;0-1; 
; Change _INT_V pin to input (pulled high).
	movlw	INT_V_BYTE		;0-1; [0010 0000] -> [WREG]
	iorwf	TRISB,W			;0-1; [TRISB<uuxu uuuu>] -> [TRIS<uu1u uuuu>]
	iorlw	PB_PROTECT		;0-1; Protect the I2C pins -> [TRISB<uu11 uu1u>]	
	movwf	TRISB			;0-1;

END_V_HW_INT_CHECK ;***********************************************************
;******************************************************************************

END_VOLTAGE_RESPONSE ;*********************************************************
;##############################################################################

;##############################################################################
EXT_RESPONSE ;****************************************************************
;******************************************************************************

EXT_HW_INT_CHECK ;** External Signal Hardware Interrupt Service Check *********
; Compare external interrupts and externalhardware interrupt mask.
	clrf	STATUS			;x-0; 
	movf	EXT_INT_HW_MASK,W ;x-0;	
	bsf		STATUS,RP0		;x-1;
	andwf	EXT_INTERRUPT,W	;x-1;
	bcf		PCLATH,3		;0-1; Program memory page 0.  
	btfsc	STATUS,Z		;0-1; Should an external HW interrupt occur?
	goto 	NO_EXT_HW_INTS	;0-1; No.

YES_EXT_HW_INTS				;0-1; Yes. Activate the _EXT interrupt pin.
; Change _INT_EXT and _INT_MSTR pins to an outputs.
	movlw	_INT_EXT_BYTE	;0-1; [0111 1111] -> [WREG]
	andlw	_INT_MSTR_BYTE	;0-1; [0111 1110] -> [WREG]
	andwf	TRISB,W			;0-1; [TRISB<xuuu uuuu>] -> [TRISB<0uuu uuu0>]
	iorlw	PB_PROTECT		;0-1; Protect the I2C pins -> [TRISB<0uu1 uu10>]		
	movwf	TRISB			;0-1;
; Set central hardware interrupt flag.
	bsf		INTERRUPTS,3	;0-1;
; Set _INT_EXT PORTB pin low.
	bcf		STATUS,RP0		;0-0; 
	bcf		PORTB,_INT_EXT	;0-0; [PORTB<xuuu uuuu>] -> [PORTB<0uuu uuuu>]
; Set _INT_MSTR PORTB pin low.
	bcf		PORTB,_INT_MSTR	;0-0; [PORTB<uuuu uuux>] -> [PORTB<uuuu uuu0>]
; Done. Hardware interrupts have been recognized and pins modified.
	bcf		PCLATH,3		;0-0; Program memory page 0.  
	goto	END_EXT_HW_INT_CHECK

NO_EXT_HW_INTS				;0-1;  No. Deactivate the _EXT interrupt pin.
; Clear the central hardware interrupt flag
	bcf		INTERRUPTS,3	;0-1;  
; Change _INT_EXT pin to input (pulled high).
	movlw	INT_EXT_BYTE	;0-1; [1000 0000] -> [WREG]
	iorwf	TRISB,W			;0-1; [TRISB<xuuu uuuu>] -> [TRIS<1uuu uuuu>]
	iorlw	PB_PROTECT		;0-1; Protect the I2C pins -> [TRISB<1uu1 uu1u>]
	movwf	TRISB			;0-1;

END_EXT_HW_INT_CHECK ;0/1; ****************************************************
;******************************************************************************

END_EXT_RESPONSE ;***********************************************************
;##############################################################################

;##############################################################################
REGULATION_RESPONSE ;**********************************************************
; REG_FLAGS<6>: 1 = Send regulation status to master interrupt; 0 = ignore.
; REG_FLAGS<7>: 0 = Regulation interrupt state (LED on)
; INTERRUPTS<7>: 1 = The regulation pin is active (low) and REG_FLAGS<6> = 1.
	clrf	STATUS			;x-0; Has user requested that regulation condition
	bcf		PCLATH,3		;0-0;
	btfss	REG_FLAGS,6		;0-0;   be sent to [INTERRUPTS] for switch control?
	goto	NO_REGULATION_RESPONSE

YES_REGULATION_RESPONSE 	; Yes. check the regulation status and set/clear 
	btfss	REG_FLAGS,7		;0-0; interrupt flag in [INTERRUPTS].
	goto	NO_REGULATION_RESPONSE ; Clear the flag and exit.

; Set _INT_MSTR PORTB pin low.
	bcf		PORTB,_INT_MSTR	;0-0; [PORTB<uuuu uuux>] -> [PORTB<uuuu uuu0>]
	bsf		STATUS,RP0		;0-1;
	bsf		INTERRUPTS,7	;0-1; Set flag to indicate regulation status.
	movlw	_INT_MSTR_BYTE	;0-1; [1111-1110] => [WREG]
	andwf	TRISB,W			;0-1; -> [TRISB<uuuu uuu0]
	iorlw	PB_PROTECT		;0-1; Protect the I2C pins -> [TRISB<uuu1 uu10>]		
	movwf	TRISB			;0-1; Master output now reflects status.
	goto	END_REGULATION_RESPONSE
	
NO_REGULATION_RESPONSE
	bsf		STATUS,RP0		;0-1;
	bcf		INTERRUPTS,7	;0-1; Clear the interrupt flag.

END_REGULATION_RESPONSE ;******************************************************
;##############################################################################

;******************************************************************************
CLR_INT ;**********************************************************************
; Check whether any unmasked GFC interrupts are active.
	banksel	INTERRUPTS		;x-1; 
	movf	INTERRUPTS,W	;x-1;
	bcf		PCLATH,3		;0-1; Program memory page 0.  
	btfss	STATUS,Z		;0-1; Are any unmasked GFC interrupts active?	
	goto	END_CLR_INT		;0-1;  Yes. Better leave the _interrupt as it was.
; No. Clear the Master Interrupt pin.
; Change _INT_MSTR pin to input (pulled high).
	movlw	INT_MSTR_BYTE	;0-1; [0000 0001] -> [WREG]
	iorwf	TRISB,W			;0-1; [TRISB<uuuu uuux>] -> [TRISB<uuuu uuu1>]
	iorlw	PB_PROTECT		;0-1; Protect the I2C pins -> [TRISB<uuu1 u011>]
	movwf	TRISB			;0-1;
END_CLR_INT ;******************************************************************
;******************************************************************************

;##############################################################################
REG_SERVICES ;*****************************************************************
; This section calculates the respective regulation fraction based on present
;	period, voltage, or external variable.
	clrf	STATUS			;x-0;
	bcf		PCLATH,3		;0-0; Program memory page 0.  
	btfss	REG_FLAGS,0		;0-0; Use this code once per cycle. (Set in RTC code)
	goto END_REG_SERVICES

	bcf		PCLATH,3		;0-0; Program memory page 0.  
	btfsc	REG_FLAGS,3		;0-0; Yes. To which event is regulation assigned?
	goto	EXTERNAL			; Regulation assigned to external events.

INTERNAL
	bcf		PCLATH,3		;0-0; Program memory page 0.  
	btfsc	REG_FLAGS,2		;0-0; Frequency, or voltage?
	goto	VOLTAGE_REG			; Regulation assigned to voltage events.

;******************************************************************************
PERIOD_REG ; PERIOD REGULATION SECTION ****************************************
; This section modified 11/5/09 to use [PER_MIN_REG] and [PER_MAX_REG] that may
; be assigned different from default values [PER_MIN_STPT] and [PER_MAX_STPT].
	clrf	STATUS			;x-0;
	bcf		PCLATH,3		;0-0; Program memory page 0.  
	btfsc	REG_FLAGS,1		;0-0;
	goto	PERIOD_REG_RELATIVE

PERIOD_REG_ABSOLUTE
	bsf		STATUS,RP1		;0-2;
	wrdswp	PER_MIN_REG, X1 ;0-2;  [PER_MIN_REG] => [X1:X2]
	wrdswp	PER_MAX_REG, X3 ;0-2;  [PER_MAX_REG] => [X3:X4]
	goto	PERIOD_REG_CONTINUE

PERIOD_REG_RELATIVE
	bsf		STATUS,RP0		;0-1;
	wrdswp	PER_MIN_REL, X1 ;0-1; [PER_MIN_REL] => [X1:X2]
	wrdswp	PER_MAX_REL, X3 ;0-1; [PER_MAX_REL] => [X3:X4]

PERIOD_REG_CONTINUE
	bsf		PCLATH,3		;1-x; Service routines are on second prog. mem. page.
	call	SUB16			;1-x; [X3:X4] = [X3:X4]-[X1:X2] (signed)

	wrdswp	X3, X5 			;1-x; [X3:X4] => [X5:X6] This is the full absolute range.
	banksel	PERIOD			;1-1;
	wrdswp	PERIOD, X3 		;1-1; [PERIOD] => [X3:X4]
	
	call	SUB16			;1-1; [X3:X4] = [X3:X4]-[X1:X2] (signed)							

	wrdswp	X5, X1 			;1-1; [X5:X6] => [X1:X2]

	; [X3:X4] = [PERIOD] - [PER_MIN_*]
	; [X1:X2] = [PER_MAX_*] - [PER_MIN_*] 						

	call	DIV16			;1-1; [X4] = 16 * [X3:X4] / [X1:X2]
;NOTE that DIV16 version 2009.0 was improved to handle the cases of division
;  by zero and negative divisors on 10/13/2009.

	byteswp	X4, REG_FRACTION ;1-1; [X4] -> [REG_FRACTION]

	bcf		PCLATH,3		;0-1; Program memory page 0.  
	goto	EXIT_REG_SERVICES
END_PERIOD_REG ;***************************************************************
;******************************************************************************

;******************************************************************************
VOLTAGE_REG ; VOLTAGE REGULATION SECTION **************************************
; This section modified 11/5/09 to use [V_MIN_REG] and [V_MAX_REG] that may
; be assigned different from default values [V_MIN_STPT] and [V_MAX_STPT].
	clrf	STATUS			;x-0;
	bcf		PCLATH,3		;0-0; Program memory page 0.  
	btfsc	REG_FLAGS,1		;0-0;
	goto	VOLTAGE_REG_RELATIVE 

VOLTAGE_REG_ABSOLUTE
	bsf		STATUS,RP1		;0-2;
	wrdswp	V_MIN_REG, X1 	;0-2; [V_MIN_REG] => [X1:X2]
	wrdswp	V_MAX_REG, X3 	;0-2; [V_MAX_REG] => [X3:X4]
	goto	VOLTAGE_REG_CONTINUE 

VOLTAGE_REG_RELATIVE
	bsf		STATUS,RP0		;0-1;
	wrdswp	V_MIN_REL, X1 	;0-1; [V_MIN_REL] => [X1:X2]
	wrdswp	V_MAX_REL, X3	;0-1; [V_MAX_REL] => [X3:X4]

VOLTAGE_REG_CONTINUE
	bsf		PCLATH,3		;1-x; Service routines are on second prog. mem. page.
	call	SUB16			;1-x; [X3:X4] = [X3:X4]-[X1:X2] (signed)

	wrdswp	X3, X5 			;1-x; [X3:X4] => [X5:X6] This is the full absolute range.
	banksel	VOLTAGE			;1-1;
	wrdswp	VOLTAGE, X3		;1-1; [VOLTAGE] => [X3:X4]					

	call	SUB16			;1-1; [X3:X4] = [X3:X4]-[X1:X2] (signed)							

	wrdswp	X5, X1			;1-1; [X5:X6] => [X1:X2]
						
	; [X3:X4] = [VOLTAGE] - [V_MIN_*]
	; [X1:X2] = [V_MAX_*] - [V_MIN_*]

	call	DIV16			;1-1; [X4] = 16 * [X3:X4] / [X1:X2]
		; NOTE: Consider division error handling.

	byteswp	X4, REG_FRACTION ;1-1; [X4] -> [REG_FRACTION]

	bcf		PCLATH,3		;0-1; Program memory page 0.  
	goto	EXIT_REG_SERVICES
END_VOLTAGE_REG ;**************************************************************
;******************************************************************************

EXTERNAL
;******************************************************************************
EXTERNAL_REG ; EXTERNAL SIGNAL REGULATION SECTION **********************************
; This section modified 11/5/09 to use [EXT_MIN_REG] and [EXT_MAX_REG] that may
; be assigned different from default values [EXT_MIN_STPT] and [EXT_MAX_STPT].
	clrf	STATUS			;x-0;
	bcf		PCLATH,3		;0-0; Program memory page 0.  
	btfsc	REG_FLAGS,1		;0-0;
	goto	EXTERNAL_REG_RELATIVE

EXTERNAL_REG_ABSOLUTE
	bsf		STATUS,RP1		;0-2; Yes. 
	wrdswp	EXT_MIN_REG, X1 ;0-2; [EXT_MIN_REG] => [X1:X2]
	wrdswp	EXT_MAX_REG, X3 ;0-2; [EXT_MAX_REG] => [X3:X4]
	goto	EXTERNAL_REG_CONTINUE

EXTERNAL_REG_RELATIVE
	bsf		STATUS,RP0		;0-1;
	wrdswp	EXT_MIN_REL, X1 ;0-1; [EXT_MIN_REL] => [X1:X2]
	wrdswp	EXT_MAX_REL, X3	;0-1; [EXT_MAX_REL] => [X3:X4]

EXTERNAL_REG_CONTINUE
	bsf		PCLATH,3		;1-x; Service routines are on second prog. mem. page.
	call	SUB16			;1-x; [X3:X4] = [X3:X4]-[X1:X2] (signed)

	clrf	STATUS			;1-0;
	wrdswp	X3, X5			;1-0; [X3:X4] => [X5:X6] This is the full absolute range.
	wrdswp	EXT, X3			;1-0; [EXT] => [X3:X4]						

	call	SUB16			;1-0; [X3:X4] = [X3:X4]-[X1:X2] (signed)							

	wrdswp	X5, X1			;1-0; [X5:X6] => [X1:X2]
						
	; [X3:X4] = [EXT] - [EXT_MIN_*]
	; [X1:X2] = [EXT_MAX_*] - [EXT_MIN_*]

	call	DIV16			;1-0; [X4] = 16 * [X3:X4] / [X1:X2]
							; NOTE: Consider division error handling.
	bsf		STATUS,RP0		;1-1;
	byteswp	X4, REG_FRACTION ;1-1; [X4] -> [REG_FRACTION]

	bcf		PCLATH,3		;0-1; Program memory page 0.  
	goto	EXIT_REG_SERVICES
END_EXTERNAL_REG ;****************************************************************
;******************************************************************************

EXIT_REG_SERVICES
	clrf	STATUS			;x-0;
	bcf		REG_FLAGS,0		;x-0; Clear the software flag from interrupt.

END_REG_SERVICES ;************************************************************
;#############################################################################

;##############################################################################
EEPROM_UPDATE ;****************************************************************
			; Rotate through registers to mirror register settings in EEPROM.
	banksel	EECON1			;x-3; Is EEPROM ready for another byte?
	bcf		PCLATH,3		;0-3; Program memory page 0.  
	btfsc	EECON1,WR		;0-3;
	goto	END_EEPROM_UPDATE

	bcf		STATUS,RP0		;0-2; Write changed register into EEPROM.
							;0-2; Point to place in register memory.
 	byteswp	EEPROM_PTR, EEADR ;0-2; [EEPROM_PTR] -> [EEADR]
	movwf	FSR				;0-2;

	bcf		STATUS,IRP		;0-2; Point to banks 0 and 1 for indirect addressing.

							;0-2; Move value of register into ind. add. reg.
							;0-2; Move updated value into the EEPROM data reg.
	byteswp	INDF, EEDATA	;0-2; [INDF] -> [EEDATA]
	bsf		PCLATH,3		;1-2; Service routines are on second prog. mem. page.
	call	EE_WRITE		;2->3; Call the subroutine to write the EEPROM 
							;	 location. NOTE: Changes to bank 3.
	bcf		STATUS,RP0		;1-2;
	incf	EEPROM_PTR,F	;1-2; Increase the pointer

	movlw	0x60			;1-2; Jump $00 -> $20 and $80 -> $A0
	andwf	EEPROM_PTR,W	;1-2;
	bcf		PCLATH,3		;0-2; Program memory page 0.  
	btfss	STATUS,Z		;0-2;
	goto	EEPROM_UPDATE_CONTINUE
	movlw	0x20			;0-2;
	iorwf	EEPROM_PTR,F	;0-2;

EEPROM_UPDATE_CONTINUE
	movlw	0x70			;0-2;	Jump $70 -> $A0 and $F0 -> $20
	xorwf	EEPROM_PTR,W	;0-2;
	andlw	0x70			;0-2;
	bcf		PCLATH,3		;0-2; Program memory page 0.  
	btfss	STATUS,Z		;0-2;
	goto	END_EEPROM_UPDATE ;0-2; [EEPROM_PTR] is OK. Continue.
	movf	EEPROM_PTR,W	;0-2; [EEPROM_PTR] is either $70 or $F0
	xorlw	0x80			;0-2; Switch pointer between banks 0 and 1
	andlw	0xA0			;0-2; Make sure pointer is either $A0 or $20
	movwf	EEPROM_PTR		;0-2; Reload pointer with $A0 or $20

END_EEPROM_UPDATE ;************************************************************
;##############################################################################

	bcf		PCLATH,3		;0-x; Program memory page 0.  
	goto	MAIN			; End of main service loop.

END_MAIN ;** End of Main Loop *************************************************
;##############################################################################

	END	;*** end of program ***************************************************
;##############################################################################
